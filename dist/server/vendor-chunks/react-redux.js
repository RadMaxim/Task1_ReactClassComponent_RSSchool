"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-redux";
exports.ids = ["vendor-chunks/react-redux"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\nvar _excluded = [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"],\n  _excluded2 = [\"reactReduxForwardedRef\"];\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// src/index.ts\n\n\n\n// src/utils/react.ts\n\nvar React =\n// prettier-ignore\n// @ts-ignore\n true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n// src/components/Context.ts\nvar ContextKey = Symbol[\"for\"](\"react-redux-context\");\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\nfunction getContext() {\n  var _gT$ContextKey;\n  if (!React.createContext) return {};\n  var contextMap = (_gT$ContextKey = gT[ContextKey]) !== null && _gT$ContextKey !== void 0 ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */new Map();\n  var realContext = contextMap.get(React.createContext);\n  if (!realContext) {\n    realContext = React.createContext(null);\n    if (true) {\n      realContext.displayName = \"ReactRedux\";\n    }\n    contextMap.set(React.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */getContext();\n\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = function notInitialized() {\n  throw new Error(\"uSES not initialized!\");\n};\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  return function useReduxContext2() {\n    var contextValue = React.useContext(context);\n    if ( true && !contextValue) {\n      throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */createReduxContextHook();\n\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = function initializeUseSelector(fn) {\n  useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\nfunction createSelectorHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  var useSelector2 = function useSelector2(selector) {\n    var equalityFnOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _ref = typeof equalityFnOrOptions === \"function\" ? {\n        equalityFn: equalityFnOrOptions\n      } : equalityFnOrOptions,\n      _ref$equalityFn = _ref.equalityFn,\n      equalityFn = _ref$equalityFn === void 0 ? refEquality : _ref$equalityFn,\n      _ref$devModeChecks = _ref.devModeChecks,\n      devModeChecks = _ref$devModeChecks === void 0 ? {} : _ref$devModeChecks;\n    if (true) {\n      if (!selector) {\n        throw new Error(\"You must pass a selector to useSelector\");\n      }\n      if (typeof selector !== \"function\") {\n        throw new Error(\"You must pass a function as a selector to useSelector\");\n      }\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(\"You must pass a function as an equality function to useSelector\");\n      }\n    }\n    var _useReduxContext = useReduxContext2(),\n      store = _useReduxContext.store,\n      subscription = _useReduxContext.subscription,\n      getServerState = _useReduxContext.getServerState,\n      stabilityCheck = _useReduxContext.stabilityCheck,\n      identityFunctionCheck = _useReduxContext.identityFunctionCheck;\n    var firstRun = React.useRef(true);\n    var wrappedSelector = React.useCallback(_defineProperty({}, selector.name, function (state) {\n      var selected = selector(state);\n      if (true) {\n        var _stabilityCheck$ident = _objectSpread({\n            stabilityCheck: stabilityCheck,\n            identityFunctionCheck: identityFunctionCheck\n          }, devModeChecks),\n          finalIdentityFunctionCheck = _stabilityCheck$ident.identityFunctionCheck,\n          finalStabilityCheck = _stabilityCheck$ident.stabilityCheck;\n        if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n          var toCompare = selector(state);\n          if (!equalityFn(selected, toCompare)) {\n            var stack = void 0;\n            try {\n              throw new Error();\n            } catch (e) {\n              ;\n              stack = e.stack;\n            }\n            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n              state: state,\n              selected: selected,\n              selected2: toCompare,\n              stack: stack\n            });\n          }\n        }\n        if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n          if (selected === state) {\n            var _stack = void 0;\n            try {\n              throw new Error();\n            } catch (e) {\n              ;\n              _stack = e.stack;\n            }\n            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n              stack: _stack\n            });\n          }\n        }\n        if (firstRun.current) firstRun.current = false;\n      }\n      return selected;\n    })[selector.name], [selector, stabilityCheck, devModeChecks.stabilityCheck]);\n    var selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: function withTypes() {\n      return useSelector2;\n    }\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */createSelectorHook();\n\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol[\"for\"](\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol[\"for\"](\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol[\"for\"](\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol[\"for\"](\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol[\"for\"](\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol[\"for\"](\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol[\"for\"](\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol[\"for\"](\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol[\"for\"](\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol[\"for\"](\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"](\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol[\"for\"](\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol[\"for\"](\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol[\"for\"](\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol[\"for\"](\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  if (typeof type === \"string\" || typeof type === \"function\") {\n    return true;\n  }\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n    return true;\n  }\n  if (_typeof(type) === \"object\" && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n    // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction typeOf(object) {\n  if (_typeof(object) === \"object\" && object !== null) {\n    var $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        {\n          var type = object.type;\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n              return type;\n            default:\n              {\n                var $$typeofType = type && type.$$typeof;\n                switch ($$typeofType) {\n                  case REACT_SERVER_CONTEXT_TYPE:\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n                  default:\n                    return $$typeof;\n                }\n              }\n          }\n        }\n      case REACT_PORTAL_TYPE:\n        {\n          return $$typeof;\n        }\n    }\n  }\n  return void 0;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {}\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(\"Unexpected value for \".concat(methodName, \" in connect.\"));\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(\"The selector for \".concat(methodName, \" of connect did not specify a value for dependsOnOwnProps.\"));\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref2) {\n  var areStatesEqual = _ref2.areStatesEqual,\n    areOwnPropsEqual = _ref2.areOwnPropsEqual,\n    areStatePropsEqual = _ref2.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, _ref3) {\n  var initMapStateToProps = _ref3.initMapStateToProps,\n    initMapDispatchToProps = _ref3.initMapDispatchToProps,\n    initMergeProps = _ref3.initMergeProps,\n    options = _objectWithoutProperties(_ref3, _excluded);\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n  if (true) {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  var boundActionCreators = {};\n  var _loop = function _loop() {\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = function () {\n        return dispatch(actionCreator.apply(void 0, arguments));\n      };\n    }\n  };\n  for (var key in actionCreators) {\n    _loop();\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (_typeof(obj) !== \"object\" || obj === null) return false;\n  var proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  var baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(\"\".concat(methodName, \"() in \").concat(displayName, \" must return a plain object. Instead received \").concat(value, \".\"));\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    var constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref4) {\n    var displayName = _ref4.displayName;\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (true) verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return function (dispatch, options) {\n    throw new Error(\"Invalid value of type \".concat(_typeof(arg), \" for \").concat(name, \" argument when connecting component \").concat(options.wrappedComponentName, \".\"));\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && _typeof(mapDispatchToProps) === \"object\" ? wrapMapToPropsConstant(function (dispatch) {\n    return (\n      // @ts-ignore\n      bindActionCreators(mapDispatchToProps, dispatch)\n    );\n  }) : !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : typeof mapDispatchToProps === \"function\" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : typeof mapStateToProps === \"function\" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return _objectSpread(_objectSpread(_objectSpread({}, ownProps), stateProps), dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref5) {\n    var displayName = _ref5.displayName,\n      areMergedPropsEqual = _ref5.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  var first = null;\n  var last = null;\n  return {\n    clear: function clear() {\n      first = null;\n      last = null;\n    },\n    notify: function notify() {\n      defaultNoopBatch(function () {\n        var listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get: function get() {\n      var listeners = [];\n      var listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe: function subscribe(callback) {\n      var isSubscribed = true;\n      var listener = last = {\n        callback: callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify: function notify() {},\n  get: function get() {\n    return [];\n  }\n};\nfunction createSubscription(store, parentSub) {\n  var unsubscribe;\n  var listeners = nullListeners;\n  var subscriptionsAmount = 0;\n  var selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    var cleanupListener = listeners.subscribe(listener);\n    var removed = false;\n    return function () {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  var subscription = {\n    addNestedSub: addNestedSub,\n    notifyNestedSubs: notifyNestedSubs,\n    handleChangeWrapper: handleChangeWrapper,\n    isSubscribed: isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: function getListeners() {\n      return listeners;\n    }\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( false && 0);\nvar isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n  if (_typeof(objA) !== \"object\" || objA === null || _typeof(objB) !== \"object\" || objB === null) {\n    return false;\n  }\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = _defineProperty(_defineProperty({}, ForwardRef, FORWARD_REF_STATICS), Memo, MEMO_STATICS);\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    var keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = function initializeConnect(fn) {\n  useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = function stringifyComponent(Comp) {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(function () {\n    return effectFunc.apply(void 0, _toConsumableArray(effectArgs));\n  }, dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return function () {};\n  var didUnsubscribe = false;\n  var lastThrownError = null;\n  var checkForUpdates = function checkForUpdates() {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    var latestStoreState = store.getState();\n    var newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  var unsubscribeWrapper = function unsubscribeWrapper() {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n  var _ref6 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    pure = _ref6.pure,\n    _ref6$areStatesEqual = _ref6.areStatesEqual,\n    areStatesEqual = _ref6$areStatesEqual === void 0 ? strictEqual : _ref6$areStatesEqual,\n    _ref6$areOwnPropsEqua = _ref6.areOwnPropsEqual,\n    areOwnPropsEqual = _ref6$areOwnPropsEqua === void 0 ? shallowEqual : _ref6$areOwnPropsEqua,\n    _ref6$areStatePropsEq = _ref6.areStatePropsEqual,\n    areStatePropsEqual = _ref6$areStatePropsEq === void 0 ? shallowEqual : _ref6$areStatePropsEq,\n    _ref6$areMergedPropsE = _ref6.areMergedPropsEqual,\n    areMergedPropsEqual = _ref6$areMergedPropsE === void 0 ? shallowEqual : _ref6$areMergedPropsE,\n    _ref6$forwardRef = _ref6.forwardRef,\n    forwardRef = _ref6$forwardRef === void 0 ? false : _ref6$forwardRef,\n    _ref6$context = _ref6.context,\n    context = _ref6$context === void 0 ? ReactReduxContext : _ref6$context;\n  if (true) {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n    }\n  }\n  var Context = context;\n  var initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  var initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  var initMergeProps = mergePropsFactory(mergeProps);\n  var shouldHandleStateChanges = Boolean(mapStateToProps);\n  var wrapWithConnect = function wrapWithConnect(WrappedComponent) {\n    if (true) {\n      var isValid = /* @__PURE__ */isValidElementType(WrappedComponent);\n      if (!isValid) throw new Error(\"You must pass a component to the function returned by connect. Instead received \".concat(stringifyComponent(WrappedComponent)));\n    }\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    var displayName = \"Connect(\".concat(wrappedComponentName, \")\");\n    var selectorFactoryOptions = {\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      displayName: displayName,\n      wrappedComponentName: wrappedComponentName,\n      WrappedComponent: WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps: initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMergeProps: initMergeProps,\n      areStatesEqual: areStatesEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areMergedPropsEqual: areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      var _React$useMemo = React.useMemo(function () {\n          var reactReduxForwardedRef2 = props.reactReduxForwardedRef,\n            wrapperProps2 = _objectWithoutProperties(props, _excluded2);\n          return [props.context, reactReduxForwardedRef2, wrapperProps2];\n        }, [props]),\n        _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n        propsContext = _React$useMemo2[0],\n        reactReduxForwardedRef = _React$useMemo2[1],\n        wrapperProps = _React$useMemo2[2];\n      var ContextToUse = React.useMemo(function () {\n        var ResultContext = Context;\n        if (propsContext !== null && propsContext !== void 0 && propsContext.Consumer) {\n          if (true) {\n            var _isValid = /* @__PURE__ */isContextConsumer(\n            // @ts-ignore\n            /* @__PURE__ */\n            React.createElement(propsContext.Consumer, null));\n            if (!_isValid) {\n              throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      var contextValue = React.useContext(ContextToUse);\n      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(\"Could not find \\\"store\\\" in the context of \\\"\".concat(displayName, \"\\\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to \").concat(displayName, \" in connect options.\"));\n      }\n      var store = didStoreComeFromProps ? props.store : contextValue.store;\n      var getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      var childPropsSelector = React.useMemo(function () {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      var _React$useMemo3 = React.useMemo(function () {\n          if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n          var subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n          var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n          return [subscription2, notifyNestedSubs2];\n        }, [store, didStoreComeFromProps, contextValue]),\n        _React$useMemo4 = _slicedToArray(_React$useMemo3, 2),\n        subscription = _React$useMemo4[0],\n        notifyNestedSubs = _React$useMemo4[1];\n      var overriddenContextValue = React.useMemo(function () {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return _objectSpread(_objectSpread({}, contextValue), {}, {\n          subscription: subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      var lastChildProps = React.useRef(void 0);\n      var lastWrapperProps = React.useRef(wrapperProps);\n      var childPropsFromStoreUpdate = React.useRef(void 0);\n      var renderIsScheduled = React.useRef(false);\n      var isMounted = React.useRef(false);\n      var latestSubscriptionCallbackError = React.useRef(void 0);\n      useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n          isMounted.current = false;\n        };\n      }, []);\n      var actualChildPropsSelector = React.useMemo(function () {\n        var selector = function selector() {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      var subscribeForReact = React.useMemo(function () {\n        var subscribe = function subscribe(reactListener) {\n          if (!subscription) {\n            return function () {};\n          }\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription,\n          // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      var actualChildProps;\n      try {\n        actualChildProps = useSyncExternalStore(\n        // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact,\n        // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? function () {\n          return childPropsSelector(getServerState(), wrapperProps);\n        } : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(function () {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      var renderedWrappedComponent = React.useMemo(function () {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */\n          React.createElement(WrappedComponent, _objectSpread(_objectSpread({}, actualChildProps), {}, {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      var renderedChild = React.useMemo(function () {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    var _Connect = React.memo(ConnectFunction);\n    var Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      var _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        return /* @__PURE__ */React.createElement(Connect, _objectSpread(_objectSpread({}, props), {}, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n      var forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider(_ref7) {\n  var store = _ref7.store,\n    context = _ref7.context,\n    children = _ref7.children,\n    serverState = _ref7.serverState,\n    _ref7$stabilityCheck = _ref7.stabilityCheck,\n    stabilityCheck = _ref7$stabilityCheck === void 0 ? \"once\" : _ref7$stabilityCheck,\n    _ref7$identityFunctio = _ref7.identityFunctionCheck,\n    identityFunctionCheck = _ref7$identityFunctio === void 0 ? \"once\" : _ref7$identityFunctio;\n  var contextValue = React.useMemo(function () {\n    var subscription = createSubscription(store);\n    return {\n      store: store,\n      subscription: subscription,\n      getServerState: serverState ? function () {\n        return serverState;\n      } : void 0,\n      stabilityCheck: stabilityCheck,\n      identityFunctionCheck: identityFunctionCheck\n    };\n  }, [store, serverState, stabilityCheck, identityFunctionCheck]);\n  var previousState = React.useMemo(function () {\n    return store.getState();\n  }, [store]);\n  useIsomorphicLayoutEffect(function () {\n    var subscription = contextValue.subscription;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return function () {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  var Context = context || ReactReduxContext;\n  return /* @__PURE__ */React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useStore.ts\nfunction createStoreHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useReduxContext2 = context === ReactReduxContext ? useReduxContext :\n  // @ts-ignore\n  createReduxContextHook(context);\n  var useStore2 = function useStore2() {\n    var _useReduxContext2 = useReduxContext2(),\n      store = _useReduxContext2.store;\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: function withTypes() {\n      return useStore2;\n    }\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  var useDispatch2 = function useDispatch2() {\n    var store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: function withTypes() {\n      return useDispatch2;\n    }\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */createDispatchHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2dDO0FBQ2lHOztBQUVqSTtBQUN1QztBQUN2QyxJQUFJSSxLQUFLO0FBQ1A7QUFDQTtBQUNBLEtBQTBCLEdBQUdELGtDQUF3QixHQUFHQSx5TEFDekQ7O0FBRUQ7QUFDQSxJQUFJRSxVQUFVLEdBQUdDLE1BQU0sT0FBSSxzQkFBc0IsQ0FBQztBQUNsRCxJQUFJQyxFQUFFLEdBQUcsT0FBT0MsVUFBVSxLQUFLLFdBQVcsR0FBR0EsVUFBVSxHQUNyRDtBQUNBLENBQUMsQ0FDRjtBQUNELFNBQVNDLFVBQVVBLENBQUEsRUFBRztFQUFBLElBQUFDLGNBQUE7RUFDcEIsSUFBSSxDQUFDTixLQUFLLENBQUNPLGFBQWEsRUFDdEIsT0FBTyxDQUFDLENBQUM7RUFDWCxJQUFNQyxVQUFVLElBQUFGLGNBQUEsR0FBR0gsRUFBRSxDQUFDRixVQUFVLENBQUMsY0FBQUssY0FBQSxjQUFBQSxjQUFBLEdBQUtILEVBQUUsQ0FBQ0YsVUFBVSxDQUFDLEdBQUcsZUFBZ0IsSUFBSVEsR0FBRyxDQUFDLENBQUU7RUFDakYsSUFBSUMsV0FBVyxHQUFHRixVQUFVLENBQUNHLEdBQUcsQ0FBQ1gsS0FBSyxDQUFDTyxhQUFhLENBQUM7RUFDckQsSUFBSSxDQUFDRyxXQUFXLEVBQUU7SUFDaEJBLFdBQVcsR0FBR1YsS0FBSyxDQUFDTyxhQUFhLENBQy9CLElBQ0YsQ0FBQztJQUNELElBQUksTUFBdUM7TUFDekNHLFdBQVcsQ0FBQ0UsV0FBVyxHQUFHLFlBQVk7SUFDeEM7SUFDQUosVUFBVSxDQUFDSyxHQUFHLENBQUNiLEtBQUssQ0FBQ08sYUFBYSxFQUFFRyxXQUFXLENBQUM7RUFDbEQ7RUFDQSxPQUFPQSxXQUFXO0FBQ3BCO0FBQ0EsSUFBSUksaUJBQWlCLEdBQUcsZUFBZ0JULFVBQVUsQ0FB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LENBQUM7O0FBRWhEO0FBQ0EsU0FBU0ksa0JBQWtCQSxDQUFBLEVBQThCO0VBQUEsSUFBN0JoVyxPQUFPLEdBQUFDLFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHTCxpQkFBaUI7RUFDckQsSUFBTWlXLFNBQVMsR0FBRzdWLE9BQU8sS0FBS0osaUJBQWlCLEdBQUdtVyxRQUFRLEdBQUdILGVBQWUsQ0FBQzVWLE9BQU8sQ0FBQztFQUNyRixJQUFNaVcsWUFBWSxHQUFHLFNBQWZBLFlBQVlBLENBQUEsRUFBUztJQUN6QixJQUFNMVUsS0FBSyxHQUFHc1UsU0FBUyxDQUFDLENBQUM7SUFDekIsT0FBT3RVLEtBQUssQ0FBQ3lFLFFBQVE7RUFDdkIsQ0FBQztFQUNEN0MsTUFBTSxDQUFDQyxNQUFNLENBQUM2UyxZQUFZLEVBQUU7SUFDMUI1UyxTQUFTLEVBQUUsU0FBQUEsVUFBQTtNQUFBLE9BQU00UyxZQUFZO0lBQUE7RUFDL0IsQ0FBQyxDQUFDO0VBQ0YsT0FBT0EsWUFBWTtBQUNyQjtBQUNBLElBQUlDLFdBQVcsR0FBRyxlQUFnQkYsa0JBQWtCLENBQUMsQ0FBQzs7QUFFdEQ7QUFDQSxJQUFJRyxLQUFLLEdBQUd0TCxnQkFBZ0I7O0FBRTVCO0FBQ0FySyxxQkFBcUIsQ0FBQzVCLHNHQUFpQyxDQUFDO0FBQ3hEcVIsaUJBQWlCLENBQUN2Uix1REFBMkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdGUtcmVhY3QtdHlwZXNjcmlwdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzPzA0MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvdXRpbHMvcmVhY3QudHNcbmltcG9ydCAqIGFzIFJlYWN0T3JpZ2luYWwgZnJvbSBcInJlYWN0XCI7XG52YXIgUmVhY3QgPSAoXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICAvLyBAdHMtaWdub3JlXG4gIFwiZGVmYXVsdFwiIGluIFJlYWN0T3JpZ2luYWwgPyBSZWFjdE9yaWdpbmFsW1wiZGVmYXVsdFwiXSA6IFJlYWN0T3JpZ2luYWxcbik7XG5cbi8vIHNyYy9jb21wb25lbnRzL0NvbnRleHQudHNcbnZhciBDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihgcmVhY3QtcmVkdXgtY29udGV4dGApO1xudmFyIGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogKFxuICAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAge31cbik7XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCBjb250ZXh0TWFwID0gZ1RbQ29udGV4dEtleV0gPz8gKGdUW0NvbnRleHRLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJlYWN0UmVkdXhcIjtcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpO1xuICB9XG4gIHJldHVybiByZWFsQ29udGV4dDtcbn1cbnZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRDb250ZXh0KCk7XG5cbi8vIHNyYy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS50c1xudmFyIG5vdEluaXRpYWxpemVkID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1U0VTIG5vdCBpbml0aWFsaXplZCFcIik7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlUmVkdXhDb250ZXh0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0MigpIHtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImNvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxudmFyIHVzZVJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVSZWR1eENvbnRleHRIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTZWxlY3Rvci50c1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZm47XG59O1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZVNlbGVjdG9yMiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHksIGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYW4gZXF1YWxpdHkgZnVuY3Rpb24gdG8gdXNlU2VsZWN0b3JgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGUsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgY29uc3QgZmlyc3RSdW4gPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICB7XG4gICAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2s6IGZpbmFsU3RhYmlsaXR5Q2hlY2tcbiAgICAgICAgICAgIH0gPSB7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCBhIGRpZmZlcmVudCByZXN1bHQgd2hlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQyOiB0b0NvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy5cIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhY2sgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KVxuICAgICAgICAgICAgICBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcbiAgICAgIFtzZWxlY3Rvciwgc3RhYmlsaXR5Q2hlY2ssIGRldk1vZGVDaGVja3Muc3RhYmlsaXR5Q2hlY2tdXG4gICAgKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpcHRpb24uYWRkTmVzdGVkU3ViLFxuICAgICAgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSB8fCBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGVxdWFsaXR5Rm5cbiAgICApO1xuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU2VsZWN0b3IyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiB1c2VTZWxlY3RvcjI7XG59XG52YXIgdXNlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JIb29rKCk7XG5cbi8vIHNyYy91dGlscy9yZWFjdC1pcy50c1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc2VydmVyX2NvbnRleHRcIik7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRToge1xuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy50c1xuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yICR7bWV0aG9kTmFtZX0gaW4gY29ubmVjdC5gKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcIm1hcFN0YXRlVG9Qcm9wc1wiIHx8IG1ldGhvZE5hbWUgPT09IFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxlY3RvciwgXCJkZXBlbmRzT25Pd25Qcm9wc1wiKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LnRzXG5mdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpXG4gICAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzXG4gICAgKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpXG4gICAgICByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIHtcbiAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgaW5pdE1lcmdlUHJvcHMsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59XG5cbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmcsIG5hbWUpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYXJnfSBmb3IgJHtuYW1lfSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7b3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZX0uYFxuICAgICk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcIm9iamVjdFwiID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcbiAgICAoZGlzcGF0Y2gpID0+IChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKVxuICAgIClcbiAgKSA6ICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KChkaXNwYXRjaCkgPT4gKHtcbiAgICBkaXNwYXRjaFxuICB9KSkgOiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoKSA9PiAoe30pKSA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21lcmdlUHJvcHMudHNcbmZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH07XG59XG5mdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSwgYXJlTWVyZ2VkUHJvcHNFcXVhbCB9KSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICBsZXQgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCBcIm1lcmdlUHJvcHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmF0Y2gudHNcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuLy8gc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICBsZXQgZmlyc3QgPSBudWxsO1xuICBsZXQgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGw7XG4gICAgICBsYXN0ID0gbnVsbDtcbiAgICB9LFxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGRlZmF1bHROb29wQmF0Y2goKCkgPT4ge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBsYXN0ID0ge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgcHJldjogbGFzdFxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeSgpIHtcbiAgfSxcbiAgZ2V0OiAoKSA9PiBbXVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMDtcbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyKCk7XG4gICAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIGxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBzZWxmU3Vic2NyaWJlZDtcbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudCsrO1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50LS07XG4gICAgaWYgKHVuc3Vic2NyaWJlICYmIHN1YnNjcmlwdGlvbnNBbW91bnQgPT09IDApIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB1bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmIChzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICBhZGROZXN0ZWRTdWIsXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICBoYW5kbGVDaGFuZ2VXcmFwcGVyLFxuICAgIGlzU3Vic2NyaWJlZCxcbiAgICB0cnlTdWJzY3JpYmU6IHRyeVN1YnNjcmliZVNlbGYsXG4gICAgdHJ5VW5zdWJzY3JpYmU6IHRyeVVuc3Vic2NyaWJlU2VsZixcbiAgICBnZXRMaXN0ZW5lcnM6ICgpID0+IGxpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gc3Vic2NyaXB0aW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50c1xudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTSB8fCBpc1JlYWN0TmF0aXZlID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4vLyBzcmMvdXRpbHMvc2hhbGxvd0VxdWFsLnRzXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9ob2lzdFN0YXRpY3MudHNcbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge1xuICBbRm9yd2FyZFJlZl06IEZPUldBUkRfUkVGX1NUQVRJQ1MsXG4gIFtNZW1vXTogTUVNT19TVEFUSUNTXG59O1xuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgaWYgKGlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfVxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFtcIiQkdHlwZW9mXCJdXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgY29uc3QgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvY29ubmVjdC50c3hcbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IG5vdEluaXRpYWxpemVkO1xudmFyIGluaXRpYWxpemVDb25uZWN0ID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZm47XG59O1xudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcbnZhciBzdHJpbmdpZnlDb21wb25lbnQgPSAoQ29tcCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhlZmZlY3RGdW5jLCBlZmZlY3RBcmdzLCBkZXBlbmRlbmNpZXMpIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBlZmZlY3RGdW5jKC4uLmVmZmVjdEFyZ3MpLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vicykge1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHM7XG4gIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGlzTW91bnRlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKSB7XG4gIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IoXG4gICAgICAgIGxhdGVzdFN0b3JlU3RhdGUsXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcbiAgICB9XG4gIH07XG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufVxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCB7XG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBwdXJlLFxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIC8vIHVzZSBSZWFjdCdzIGZvcndhcmRSZWYgdG8gZXhwb3NlIGEgcmVmIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudFxuICBmb3J3YXJkUmVmID0gZmFsc2UsXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxuICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHRcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHB1cmUgIT09IHZvaWQgMCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSAoV3JhcHBlZENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIjtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCAuLi53cmFwcGVyUHJvcHMyIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgd3JhcHBlclByb3BzMl07XG4gICAgICB9LCBbcHJvcHNdKTtcbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgUmVzdWx0Q29udGV4dCA9IENvbnRleHQ7XG4gICAgICAgIGlmIChwcm9wc0NvbnRleHQ/LkNvbnN1bWVyKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc0NvbnRleHRDb25zdW1lcihcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIGFzIGBwcm9wcy5jb250ZXh0YFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZXN1bHRDb250ZXh0ID0gcHJvcHNDb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzdWx0Q29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTtcbiAgICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dFRvVXNlKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPSBCb29sZWFuKGNvbnRleHRWYWx1ZSkgJiYgQm9vbGVhbihjb250ZXh0VmFsdWUuc3RvcmUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZGlkU3RvcmVDb21lRnJvbVByb3BzICYmICFkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIFwic3RvcmVcIiBpbiB0aGUgY29udGV4dCBvZiBcIiR7ZGlzcGxheU5hbWV9XCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sIG9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIHRvICR7ZGlzcGxheU5hbWV9IGluIGNvbm5lY3Qgb3B0aW9ucy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHByb3BzLnN0b3JlIDogY29udGV4dFZhbHVlLnN0b3JlO1xuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA/IGNvbnRleHRWYWx1ZS5nZXRTZXJ2ZXJTdGF0ZSA6IHN0b3JlLmdldFN0YXRlO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICAgIH0sIFtzdG9yZV0pO1xuICAgICAgY29uc3QgW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgICAgICAgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uMiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyB2b2lkIDAgOiBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG5vdGlmeU5lc3RlZFN1YnMyID0gc3Vic2NyaXB0aW9uMi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQoc3Vic2NyaXB0aW9uMik7XG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uMiwgbm90aWZ5TmVzdGVkU3ViczJdO1xuICAgICAgfSwgW3N0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZV0pO1xuICAgICAgY29uc3Qgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNvbnRleHRWYWx1ZSxcbiAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgICAgfTtcbiAgICAgIH0sIFtkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZSwgc3Vic2NyaXB0aW9uXSk7XG4gICAgICBjb25zdCBsYXN0Q2hpbGRQcm9wcyA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IFJlYWN0LnVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgICAgY29uc3QgcmVuZGVySXNTY2hlZHVsZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSBSZWFjdC51c2VSZWYoXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGNvbnN0IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc1NlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHdyYXBwZXJQcm9wcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH0sIFtzdG9yZSwgd3JhcHBlclByb3BzXSk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVGb3JSZWFjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmUgPSAocmVhY3RMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZVVwZGF0ZXMoXG4gICAgICAgICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICAgICAgaXNNb3VudGVkLFxuICAgICAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgICAgICAgICByZWFjdExpc3RlbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZTtcbiAgICAgIH0sIFtzdWJzY3JpcHRpb25dKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgd3JhcHBlclByb3BzLFxuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzXG4gICAgICBdKTtcbiAgICAgIGxldCBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0dWFsQ2hpbGRQcm9wcyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIC8vIFRPRE8gV2UncmUgcGFzc2luZyB0aHJvdWdoIGEgYmlnIHdyYXBwZXIgdGhhdCBkb2VzIGEgYnVuY2ggb2YgZXh0cmEgc2lkZSBlZmZlY3RzIGJlc2lkZXMgc3Vic2NyaWJpbmdcbiAgICAgICAgICBzdWJzY3JpYmVGb3JSZWFjdCxcbiAgICAgICAgICAvLyBUT0RPIFRoaXMgaXMgaW5jcmVkaWJseSBoYWNreS4gV2UndmUgYWxyZWFkeSBwcm9jZXNzZWQgdGhlIHN0b3JlIHVwZGF0ZSBhbmQgY2FsY3VsYXRlZCBuZXcgY2hpbGQgcHJvcHMsXG4gICAgICAgICAgLy8gVE9ETyBhbmQgd2UncmUganVzdCBwYXNzaW5nIHRoYXQgdGhyb3VnaCBzbyBpdCB0cmlnZ2VycyBhIHJlLXJlbmRlciBmb3IgdXMgcmF0aGVyIHRoYW4gcmVseWluZyBvbiBgdVNFU2AuXG4gICAgICAgICAgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgIGdldFNlcnZlclN0YXRlID8gKCkgPT4gY2hpbGRQcm9wc1NlbGVjdG9yKGdldFNlcnZlclN0YXRlKCksIHdyYXBwZXJQcm9wcykgOiBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XG4ke2xhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFja31cblxuYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5hY3R1YWxDaGlsZFByb3BzLFxuICAgICAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pO1xuICAgICAgY29uc3QgcmVuZGVyZWRDaGlsZCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRUb1VzZS5Qcm92aWRlciwgeyB2YWx1ZTogb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSB9LCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcbiAgICAgIHJldHVybiByZW5kZXJlZENoaWxkO1xuICAgIH1cbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKTtcbiAgICBjb25zdCBDb25uZWN0ID0gX0Nvbm5lY3Q7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gQ29ubmVjdEZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgaWYgKGZvcndhcmRSZWYpIHtcbiAgICAgIGNvbnN0IF9mb3J3YXJkZWQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3QsIHsgLi4ucHJvcHMsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlZiB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IF9mb3J3YXJkZWQ7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbiAgcmV0dXJuIHdyYXBXaXRoQ29ubmVjdDtcbn1cbnZhciBjb25uZWN0X2RlZmF1bHQgPSBjb25uZWN0O1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92aWRlci50c3hcbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgc3RvcmUsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICBzZXJ2ZXJTdGF0ZSxcbiAgc3RhYmlsaXR5Q2hlY2sgPSBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gXCJvbmNlXCJcbn0pIHtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHZvaWQgMCxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfTtcbiAgfSwgW3N0b3JlLCBzZXJ2ZXJTdGF0ZSwgc3RhYmlsaXR5Q2hlY2ssIGlkZW50aXR5RnVuY3Rpb25DaGVja10pO1xuICBjb25zdCBwcmV2aW91c1N0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLCBbc3RvcmVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdWJzY3JpcHRpb24gfSA9IGNvbnRleHRWYWx1ZTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gc3RvcmUuZ2V0U3RhdGUoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSB2b2lkIDA7XG4gICAgfTtcbiAgfSwgW2NvbnRleHRWYWx1ZSwgcHJldmlvdXNTdGF0ZV0pO1xuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbik7XG59XG52YXIgUHJvdmlkZXJfZGVmYXVsdCA9IFByb3ZpZGVyO1xuXG4vLyBzcmMvaG9va3MvdXNlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXG4gICk7XG4gIGNvbnN0IHVzZVN0b3JlMiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUyXG4gIH0pO1xuICByZXR1cm4gdXNlU3RvcmUyO1xufVxudmFyIHVzZVN0b3JlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVN0b3JlSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlRGlzcGF0Y2gudHNcbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlU3RvcmUyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlRGlzcGF0Y2gyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUyKCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZURpc3BhdGNoMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gyXG4gIH0pO1xuICByZXR1cm4gdXNlRGlzcGF0Y2gyO1xufVxudmFyIHVzZURpc3BhdGNoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURpc3BhdGNoSG9vaygpO1xuXG4vLyBzcmMvZXhwb3J0cy50c1xudmFyIGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDtcblxuLy8gc3JjL2luZGV4LnRzXG5pbml0aWFsaXplVXNlU2VsZWN0b3IodXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKTtcbmluaXRpYWxpemVDb25uZWN0KFJlYWN0Mi51c2VTeW5jRXh0ZXJuYWxTdG9yZSk7XG5leHBvcnQge1xuICBQcm92aWRlcl9kZWZhdWx0IGFzIFByb3ZpZGVyLFxuICBSZWFjdFJlZHV4Q29udGV4dCxcbiAgYmF0Y2gsXG4gIGNvbm5lY3RfZGVmYXVsdCBhcyBjb25uZWN0LFxuICBjcmVhdGVEaXNwYXRjaEhvb2ssXG4gIGNyZWF0ZVNlbGVjdG9ySG9vayxcbiAgY3JlYXRlU3RvcmVIb29rLFxuICBzaGFsbG93RXF1YWwsXG4gIHVzZURpc3BhdGNoLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0MiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIiwiUmVhY3RPcmlnaW5hbCIsIlJlYWN0IiwiQ29udGV4dEtleSIsIlN5bWJvbCIsImdUIiwiZ2xvYmFsVGhpcyIsImdldENvbnRleHQiLCJfZ1QkQ29udGV4dEtleSIsImNyZWF0ZUNvbnRleHQiLCJjb250ZXh0TWFwIiwiTWFwIiwicmVhbENvbnRleHQiLCJnZXQiLCJkaXNwbGF5TmFtZSIsInNldCIsIlJlYWN0UmVkdXhDb250ZXh0Iiwibm90SW5pdGlhbGl6ZWQiLCJFcnJvciIsImNyZWF0ZVJlZHV4Q29udGV4dEhvb2siLCJjb250ZXh0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwidXNlUmVkdXhDb250ZXh0MiIsImNvbnRleHRWYWx1ZSIsInVzZUNvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQiLCJpbml0aWFsaXplVXNlU2VsZWN0b3IiLCJmbiIsInJlZkVxdWFsaXR5IiwiYSIsImIiLCJjcmVhdGVTZWxlY3Rvckhvb2siLCJ1c2VTZWxlY3RvcjIiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm5Pck9wdGlvbnMiLCJfcmVmIiwiZXF1YWxpdHlGbiIsIl9yZWYkZXF1YWxpdHlGbiIsIl9yZWYkZGV2TW9kZUNoZWNrcyIsImRldk1vZGVDaGVja3MiLCJfdXNlUmVkdXhDb250ZXh0Iiwic3RvcmUiLCJzdWJzY3JpcHRpb24iLCJnZXRTZXJ2ZXJTdGF0ZSIsInN0YWJpbGl0eUNoZWNrIiwiaWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmlyc3RSdW4iLCJ1c2VSZWYiLCJ3cmFwcGVkU2VsZWN0b3IiLCJ1c2VDYWxsYmFjayIsIl9kZWZpbmVQcm9wZXJ0eSIsIm5hbWUiLCJzdGF0ZSIsInNlbGVjdGVkIiwiX3N0YWJpbGl0eUNoZWNrJGlkZW50IiwiX29iamVjdFNwcmVhZCIsImZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmluYWxTdGFiaWxpdHlDaGVjayIsImN1cnJlbnQiLCJ0b0NvbXBhcmUiLCJzdGFjayIsImUiLCJjb25zb2xlIiwid2FybiIsInNlbGVjdGVkMiIsInNlbGVjdGVkU3RhdGUiLCJhZGROZXN0ZWRTdWIiLCJnZXRTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJPYmplY3QiLCJhc3NpZ24iLCJ3aXRoVHlwZXMiLCJ1c2VTZWxlY3RvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsIkZvcndhcmRSZWYiLCJNZW1vIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIl90eXBlb2YiLCIkJHR5cGVvZiIsImdldE1vZHVsZUlkIiwidHlwZU9mIiwib2JqZWN0IiwiJCR0eXBlb2ZUeXBlIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJpc01lbW8iLCJ3YXJuaW5nIiwibWVzc2FnZSIsImVycm9yIiwidmVyaWZ5IiwibWV0aG9kTmFtZSIsImNvbmNhdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZlcmlmeVN1YnNlbGVjdG9ycyIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIm1lcmdlUHJvcHMiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImRpc3BhdGNoIiwiX3JlZjIiLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJoYXNSdW5BdExlYXN0T25jZSIsIm93blByb3BzIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJtZXJnZWRQcm9wcyIsImhhbmRsZUZpcnN0Q2FsbCIsImZpcnN0U3RhdGUiLCJmaXJzdE93blByb3BzIiwiaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSIsImRlcGVuZHNPbk93blByb3BzIiwiaGFuZGxlTmV3UHJvcHMiLCJoYW5kbGVOZXdTdGF0ZSIsIm5leHRTdGF0ZVByb3BzIiwic3RhdGVQcm9wc0NoYW5nZWQiLCJoYW5kbGVTdWJzZXF1ZW50Q2FsbHMiLCJuZXh0U3RhdGUiLCJuZXh0T3duUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJzdGF0ZUNoYW5nZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yIiwiZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsIl9yZWYzIiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVyZ2VQcm9wcyIsIm9wdGlvbnMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfZXhjbHVkZWQiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJfbG9vcCIsImFjdGlvbkNyZWF0b3IiLCJrZXkiLCJhcHBseSIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ2YWx1ZSIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiY29uc3RhbnQiLCJjb25zdGFudFNlbGVjdG9yIiwiZ2V0RGVwZW5kc09uT3duUHJvcHMiLCJtYXBUb1Byb3BzIiwiQm9vbGVhbiIsIndyYXBNYXBUb1Byb3BzRnVuYyIsImluaXRQcm94eVNlbGVjdG9yIiwiX3JlZjQiLCJwcm94eSIsIm1hcFRvUHJvcHNQcm94eSIsInN0YXRlT3JEaXNwYXRjaCIsImRldGVjdEZhY3RvcnlBbmRWZXJpZnkiLCJwcm9wcyIsImNyZWF0ZUludmFsaWRBcmdGYWN0b3J5IiwiYXJnIiwid3JhcHBlZENvbXBvbmVudE5hbWUiLCJtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5IiwibWFwU3RhdGVUb1Byb3BzRmFjdG9yeSIsImRlZmF1bHRNZXJnZVByb3BzIiwid3JhcE1lcmdlUHJvcHNGdW5jIiwiaW5pdE1lcmdlUHJvcHNQcm94eSIsIl9yZWY1IiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImhhc1J1bk9uY2UiLCJtZXJnZVByb3BzUHJveHkiLCJuZXh0TWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzRmFjdG9yeSIsImRlZmF1bHROb29wQmF0Y2giLCJjYWxsYmFjayIsImNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbiIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwibm90aWZ5IiwibGlzdGVuZXIiLCJuZXh0IiwibGlzdGVuZXJzIiwicHVzaCIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsInByZXYiLCJ1bnN1YnNjcmliZSIsIm51bGxMaXN0ZW5lcnMiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJwYXJlbnRTdWIiLCJzdWJzY3JpcHRpb25zQW1vdW50Iiwic2VsZlN1YnNjcmliZWQiLCJ0cnlTdWJzY3JpYmUiLCJjbGVhbnVwTGlzdGVuZXIiLCJyZW1vdmVkIiwidHJ5VW5zdWJzY3JpYmUiLCJub3RpZnlOZXN0ZWRTdWJzIiwiaGFuZGxlQ2hhbmdlV3JhcHBlciIsIm9uU3RhdGVDaGFuZ2UiLCJ0cnlTdWJzY3JpYmVTZWxmIiwidHJ5VW5zdWJzY3JpYmVTZWxmIiwiZ2V0TGlzdGVuZXJzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiaXMiLCJ4IiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJpIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb250ZXh0VHlwZXMiLCJkZWZhdWx0UHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJtaXhpbnMiLCJwcm9wVHlwZXMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwicmVuZGVyIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsImdldFN0YXRpY3MiLCJjb21wb25lbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvYmplY3RQcm90b3R5cGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImluaGVyaXRlZENvbXBvbmVudCIsInRhcmdldFN0YXRpY3MiLCJzb3VyY2VTdGF0aWNzIiwiZGVzY3JpcHRvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiaW5pdGlhbGl6ZUNvbm5lY3QiLCJOT19TVUJTQ1JJUFRJT05fQVJSQVkiLCJzdHJpbmdpZnlDb21wb25lbnQiLCJDb21wIiwiSlNPTiIsInN0cmluZ2lmeSIsImVyciIsIlN0cmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyIsImVmZmVjdEZ1bmMiLCJlZmZlY3RBcmdzIiwiZGVwZW5kZW5jaWVzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiY2FwdHVyZVdyYXBwZXJQcm9wcyIsImxhc3RXcmFwcGVyUHJvcHMiLCJsYXN0Q2hpbGRQcm9wcyIsInJlbmRlcklzU2NoZWR1bGVkIiwid3JhcHBlclByb3BzIiwiY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSIsInN1YnNjcmliZVVwZGF0ZXMiLCJzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMiLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJuZXdDaGlsZFByb3BzIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwic3RyaWN0RXF1YWwiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uIiwiY29ubmVjdCIsIl9yZWY2IiwicHVyZSIsIl9yZWY2JGFyZVN0YXRlc0VxdWFsIiwiX3JlZjYkYXJlT3duUHJvcHNFcXVhIiwiX3JlZjYkYXJlU3RhdGVQcm9wc0VxIiwiX3JlZjYkYXJlTWVyZ2VkUHJvcHNFIiwiX3JlZjYkZm9yd2FyZFJlZiIsImZvcndhcmRSZWYiLCJfcmVmNiRjb250ZXh0IiwiQ29udGV4dCIsIndyYXBXaXRoQ29ubmVjdCIsIldyYXBwZWRDb21wb25lbnQiLCJpc1ZhbGlkIiwic2VsZWN0b3JGYWN0b3J5T3B0aW9ucyIsIkNvbm5lY3RGdW5jdGlvbiIsIl9SZWFjdCR1c2VNZW1vIiwidXNlTWVtbyIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyIiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZiIsIndyYXBwZXJQcm9wczIiLCJfZXhjbHVkZWQyIiwiX1JlYWN0JHVzZU1lbW8yIiwiX3NsaWNlZFRvQXJyYXkiLCJwcm9wc0NvbnRleHQiLCJDb250ZXh0VG9Vc2UiLCJSZXN1bHRDb250ZXh0IiwiQ29uc3VtZXIiLCJkaWRTdG9yZUNvbWVGcm9tUHJvcHMiLCJkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCIsIl9SZWFjdCR1c2VNZW1vMyIsInN1YnNjcmlwdGlvbjIiLCJub3RpZnlOZXN0ZWRTdWJzMiIsImJpbmQiLCJfUmVhY3QkdXNlTWVtbzQiLCJvdmVycmlkZGVuQ29udGV4dFZhbHVlIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInN1YnNjcmliZUZvclJlYWN0IiwicmVhY3RMaXN0ZW5lciIsImFjdHVhbENoaWxkUHJvcHMiLCJyZW5kZXJlZFdyYXBwZWRDb21wb25lbnQiLCJyZWYiLCJyZW5kZXJlZENoaWxkIiwiUHJvdmlkZXIiLCJfQ29ubmVjdCIsIm1lbW8iLCJDb25uZWN0IiwiX2ZvcndhcmRlZCIsImZvcndhcmRDb25uZWN0UmVmIiwiZm9yd2FyZGVkIiwiY29ubmVjdF9kZWZhdWx0IiwiX3JlZjciLCJjaGlsZHJlbiIsInNlcnZlclN0YXRlIiwiX3JlZjckc3RhYmlsaXR5Q2hlY2siLCJfcmVmNyRpZGVudGl0eUZ1bmN0aW8iLCJwcmV2aW91c1N0YXRlIiwiUHJvdmlkZXJfZGVmYXVsdCIsImNyZWF0ZVN0b3JlSG9vayIsInVzZVN0b3JlMiIsIl91c2VSZWR1eENvbnRleHQyIiwidXNlU3RvcmUiLCJjcmVhdGVEaXNwYXRjaEhvb2siLCJ1c2VEaXNwYXRjaDIiLCJ1c2VEaXNwYXRjaCIsImJhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/react-redux.mjs\n");

/***/ })

};
;