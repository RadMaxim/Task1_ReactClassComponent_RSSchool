"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/reselect";
exports.ids = ["vendor-chunks/reselect"];
exports.modules = {

/***/ "(ssr)/./node_modules/reselect/dist/reselect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/reselect/dist/reselect.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: () => (/* binding */ createSelector),\n/* harmony export */   createSelectorCreator: () => (/* binding */ createSelectorCreator),\n/* harmony export */   createStructuredSelector: () => (/* binding */ createStructuredSelector),\n/* harmony export */   lruMemoize: () => (/* binding */ lruMemoize),\n/* harmony export */   referenceEqualityCheck: () => (/* binding */ referenceEqualityCheck),\n/* harmony export */   setGlobalDevModeChecks: () => (/* binding */ setGlobalDevModeChecks),\n/* harmony export */   unstable_autotrackMemoize: () => (/* binding */ autotrackMemoize),\n/* harmony export */   weakMapMemoize: () => (/* binding */ weakMapMemoize)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = function runIdentityFunctionCheck(resultFunc, inputSelectorsResults, outputSelectorResult) {\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n    var isInputSameAsOutput = false;\n    try {\n      var emptyObject = {};\n      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;\n    } catch (_unused) {}\n    if (isInputSameAsOutput) {\n      var stack = void 0;\n      try {\n        throw new Error();\n      } catch (e) {\n        ;\n        stack = e.stack;\n      }\n      console.warn(\"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\", {\n        stack: stack\n      });\n    }\n  }\n};\n\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = function runInputStabilityCheck(inputSelectorResultsObject, options, inputSelectorArgs) {\n  var memoize = options.memoize,\n    memoizeOptions = options.memoizeOptions;\n  var inputSelectorResults = inputSelectorResultsObject.inputSelectorResults,\n    inputSelectorResultsCopy = inputSelectorResultsObject.inputSelectorResultsCopy;\n  var createAnEmptyObject = memoize.apply(void 0, [function () {\n    return {};\n  }].concat(_toConsumableArray(memoizeOptions)));\n  var areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n  if (!areInputSelectorResultsEqual) {\n    var stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      stack = e.stack;\n    }\n    console.warn(\"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\", {\n      arguments: inputSelectorArgs,\n      firstInputs: inputSelectorResults,\n      secondInputs: inputSelectorResultsCopy,\n      stack: stack\n    });\n  }\n};\n\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = function setGlobalDevModeChecks(devModeChecks) {\n  Object.assign(globalDevModeChecks, devModeChecks);\n};\n\n// src/utils.ts\nvar NOT_FOUND = /* @__PURE__ */Symbol(\"NOT_FOUND\");\nfunction assertIsFunction(func) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected a function, instead received \".concat(_typeof(func));\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsObject(object) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected an object, instead received \".concat(_typeof(object));\n  if (_typeof(object) !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsArrayOfFunctions(array) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected all items to be functions, instead received the following types: \";\n  if (!array.every(function (item) {\n    return typeof item === \"function\";\n  })) {\n    var itemTypes = array.map(function (item) {\n      return typeof item === \"function\" ? \"function \".concat(item.name || \"unnamed\", \"()\") : _typeof(item);\n    }).join(\", \");\n    throw new TypeError(\"\".concat(errorMessage, \"[\").concat(itemTypes, \"]\"));\n  }\n}\nvar ensureIsArray = function ensureIsArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\nfunction getDependencies(createSelectorArgs) {\n  var dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(dependencies, \"createSelector expects all input-selectors to be functions, but received the following types: \");\n  return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  var inputSelectorResults = [];\n  var length = dependencies.length;\n  for (var i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n  return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = function getDevModeChecksExecutionInfo(firstRun, devModeChecks) {\n  var _globalDevModeChecks$ = _objectSpread(_objectSpread({}, globalDevModeChecks), devModeChecks),\n    identityFunctionCheck = _globalDevModeChecks$.identityFunctionCheck,\n    inputStabilityCheck = _globalDevModeChecks$.inputStabilityCheck;\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n};\n\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = /*#__PURE__*/function () {\n  function Cell(initialValue) {\n    var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n    _classCallCheck(this, Cell);\n    _defineProperty(this, \"revision\", $REVISION);\n    _defineProperty(this, \"_value\", void 0);\n    _defineProperty(this, \"_lastValue\", void 0);\n    _defineProperty(this, \"_isEqual\", tripleEq);\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  }\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  return _createClass(Cell, [{\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER;\n      (_CURRENT_TRACKER = CURRENT_TRACKER) === null || _CURRENT_TRACKER === void 0 || _CURRENT_TRACKER.add(this);\n      return this._value;\n    }\n    // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    ,\n    set: function set(newValue) {\n      if (this.value === newValue) return;\n      this._value = newValue;\n      this.revision = ++$REVISION;\n    }\n  }]);\n}();\nfunction tripleEq(a, b) {\n  return a === b;\n}\nvar TrackingCache = /*#__PURE__*/function () {\n  function TrackingCache(fn) {\n    _classCallCheck(this, TrackingCache);\n    _defineProperty(this, \"_cachedValue\", void 0);\n    _defineProperty(this, \"_cachedRevision\", -1);\n    _defineProperty(this, \"_deps\", []);\n    _defineProperty(this, \"hits\", 0);\n    _defineProperty(this, \"fn\", void 0);\n    this.fn = fn;\n  }\n  return _createClass(TrackingCache, [{\n    key: \"clear\",\n    value: function clear() {\n      this._cachedValue = void 0;\n      this._cachedRevision = -1;\n      this._deps = [];\n      this.hits = 0;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER2;\n      if (this.revision > this._cachedRevision) {\n        var fn = this.fn;\n        var currentTracker = /* @__PURE__ */new Set();\n        var prevTracker = CURRENT_TRACKER;\n        CURRENT_TRACKER = currentTracker;\n        this._cachedValue = fn();\n        CURRENT_TRACKER = prevTracker;\n        this.hits++;\n        this._deps = Array.from(currentTracker);\n        this._cachedRevision = this.revision;\n      }\n      (_CURRENT_TRACKER2 = CURRENT_TRACKER) === null || _CURRENT_TRACKER2 === void 0 || _CURRENT_TRACKER2.add(this);\n      return this._cachedValue;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return Math.max.apply(Math, _toConsumableArray(this._deps.map(function (d) {\n        return d.revision;\n      })).concat([0]));\n    }\n  }]);\n}();\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n  return cell.value;\n}\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\"setValue must be passed a tracked store created with `createStorage`.\");\n  }\n  storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue) {\n  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n  return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n  assertIsFunction(fn, \"the first parameter to `createCache` must be a function\");\n  return new TrackingCache(fn);\n}\n\n// src/autotrackMemoize/tracking.ts\nvar neverEq = function neverEq(a, b) {\n  return false;\n};\nfunction createTag() {\n  return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\nvar consumeCollection = function consumeCollection(node) {\n  var tag = node.collectionTag;\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n  getValue(tag);\n};\nvar dirtyCollection = function dirtyCollection(node) {\n  var tag = node.collectionTag;\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n};\n\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = /*#__PURE__*/_createClass(function ObjectTreeNode(value) {\n  _classCallCheck(this, ObjectTreeNode);\n  _defineProperty(this, \"proxy\", new Proxy(this, objectProxyHandler));\n  _defineProperty(this, \"tag\", createTag());\n  _defineProperty(this, \"tags\", {});\n  _defineProperty(this, \"children\", {});\n  _defineProperty(this, \"collectionTag\", null);\n  _defineProperty(this, \"id\", nextId++);\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\nvar objectProxyHandler = {\n  get: function get(node, key) {\n    function calculateResult() {\n      var value = node.value;\n      var childValue = Reflect.get(value, key);\n      if (_typeof(key) === \"symbol\") {\n        return childValue;\n      }\n      if (key in proto) {\n        return childValue;\n      }\n      if (_typeof(childValue) === \"object\" && childValue !== null) {\n        var childNode = node.children[key];\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n        return childNode.proxy;\n      } else {\n        var tag = node.tags[key];\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n        getValue(tag);\n        return childValue;\n      }\n    }\n    var res = calculateResult();\n    return res;\n  },\n  ownKeys: function ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has: function has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\nvar ArrayTreeNode = /*#__PURE__*/_createClass(function ArrayTreeNode(value) {\n  _classCallCheck(this, ArrayTreeNode);\n  _defineProperty(this, \"proxy\", new Proxy([this], arrayProxyHandler));\n  _defineProperty(this, \"tag\", createTag());\n  _defineProperty(this, \"tags\", {});\n  _defineProperty(this, \"children\", {});\n  _defineProperty(this, \"collectionTag\", null);\n  _defineProperty(this, \"id\", nextId++);\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\nvar arrayProxyHandler = {\n  get: function get(_ref, key) {\n    var _ref2 = _slicedToArray(_ref, 1),\n      node = _ref2[0];\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys: function ownKeys(_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n      node = _ref4[0];\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_ref5, prop) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n      node = _ref6[0];\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has: function has(_ref7, prop) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n      node = _ref8[0];\n    return objectProxyHandler.has(node, prop);\n  }\n};\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n  return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n  var value = node.value,\n    tags = node.tags,\n    children = node.children;\n  node.value = newValue;\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      var oldKeysSize = 0;\n      var newKeysSize = 0;\n      var anyKeysAdded = false;\n      for (var _key in value) {\n        oldKeysSize++;\n      }\n      for (var key in newValue) {\n        newKeysSize++;\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n      var isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n  for (var _key2 in tags) {\n    var childValue = value[_key2];\n    var newChildValue = newValue[_key2];\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[_key2], newChildValue);\n    }\n    if (_typeof(newChildValue) === \"object\" && newChildValue !== null) {\n      delete tags[_key2];\n    }\n  }\n  for (var _key3 in children) {\n    var childNode = children[_key3];\n    var _newChildValue = newValue[_key3];\n    var _childValue = childNode.value;\n    if (_childValue === _newChildValue) {\n      continue;\n    } else if (_typeof(_newChildValue) === \"object\" && _newChildValue !== null) {\n      updateNode(childNode, _newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[_key3];\n    }\n  }\n}\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n  dirtyCollection(node);\n  for (var key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n  for (var _key4 in node.children) {\n    deleteNode(node.children[_key4]);\n  }\n}\n\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = void 0;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    });\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex];\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    }\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({\n        key: key,\n        value: value\n      });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\nvar referenceEqualityCheck = function referenceEqualityCheck(a, b) {\n  return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n    var length = prev.length;\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = _typeof(equalityCheckOrOptions) === \"object\" ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n    equalityCheck = _providedOptions$equa === void 0 ? referenceEqualityCheck : _providedOptions$equa,\n    _providedOptions$maxS = providedOptions.maxSize,\n    maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n    resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var resultsCount = 0;\n  var cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n  function memoized() {\n    var value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = function () {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n  var node = createNode([]);\n  var lastArgs = null;\n  var shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  var cache = createCache(function () {\n    var res = func.apply(null, node.proxy);\n    return res;\n  });\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n    return cache.value;\n  }\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n  return memoized;\n}\n\n// src/weakMapMemoize.ts\nvar StrongRef = /*#__PURE__*/function () {\n  function StrongRef(value) {\n    _classCallCheck(this, StrongRef);\n    this.value = value;\n  }\n  return _createClass(StrongRef, [{\n    key: \"deref\",\n    value: function deref() {\n      return this.value;\n    }\n  }]);\n}();\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\nfunction weakMapMemoize(func) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var fnNode = createCacheNode();\n  var resultEqualityCheck = options.resultEqualityCheck;\n  var lastResult;\n  var resultsCount = 0;\n  function memoized() {\n    var cacheNode = fnNode;\n    var length = arguments.length;\n    for (var i = 0, l = length; i < l; i++) {\n      var arg = arguments[i];\n      if (typeof arg === \"function\" || _typeof(arg) === \"object\" && arg !== null) {\n        var objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */new WeakMap();\n        }\n        var objectNode = objectCache.get(arg);\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        var primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */new Map();\n        }\n        var primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    var terminatedNode = cacheNode;\n    var result;\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        var _lastResult$deref, _lastResult, _lastResult$deref2;\n        var lastResultValue = (_lastResult$deref = (_lastResult = lastResult) === null || _lastResult === void 0 || (_lastResult$deref2 = _lastResult.deref) === null || _lastResult$deref2 === void 0 ? void 0 : _lastResult$deref2.call(_lastResult)) !== null && _lastResult$deref !== void 0 ? _lastResult$deref : lastResult;\n        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n          result = lastResultValue;\n          resultsCount !== 0 && resultsCount--;\n        }\n        var needsWeakRef = _typeof(result) === \"object\" && result !== null || typeof result === \"function\";\n        lastResult = needsWeakRef ? new Ref(result) : result;\n      }\n    }\n    terminatedNode.s = TERMINATED;\n    terminatedNode.v = result;\n    return result;\n  }\n  memoized.clearCache = function () {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    memoizeOptionsFromArgs[_key5 - 1] = arguments[_key5];\n  }\n  var createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n  var createSelector2 = function createSelector2() {\n    for (var _len2 = arguments.length, createSelectorArgs = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n      createSelectorArgs[_key6] = arguments[_key6];\n    }\n    var _recomputations = 0;\n    var _dependencyRecomputations = 0;\n    var _lastResult2;\n    var directlyPassedOptions = {};\n    var resultFunc = createSelectorArgs.pop();\n    if (_typeof(resultFunc) === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n    assertIsFunction(resultFunc, \"createSelector expects an output function after the inputs, but received: [\".concat(_typeof(resultFunc), \"]\"));\n    var combinedOptions = _objectSpread(_objectSpread({}, createSelectorCreatorOptions), directlyPassedOptions);\n    var memoize = combinedOptions.memoize,\n      _combinedOptions$memo = combinedOptions.memoizeOptions,\n      memoizeOptions = _combinedOptions$memo === void 0 ? [] : _combinedOptions$memo,\n      _combinedOptions$args = combinedOptions.argsMemoize,\n      argsMemoize = _combinedOptions$args === void 0 ? weakMapMemoize : _combinedOptions$args,\n      _combinedOptions$args2 = combinedOptions.argsMemoizeOptions,\n      argsMemoizeOptions = _combinedOptions$args2 === void 0 ? [] : _combinedOptions$args2,\n      _combinedOptions$devM = combinedOptions.devModeChecks,\n      devModeChecks = _combinedOptions$devM === void 0 ? {} : _combinedOptions$devM;\n    var finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    var finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    var dependencies = getDependencies(createSelectorArgs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++;\n      return resultFunc.apply(null, arguments);\n    }].concat(_toConsumableArray(finalMemoizeOptions)));\n    var firstRun = true;\n    var selector = argsMemoize.apply(void 0, [function dependenciesChecker() {\n      _dependencyRecomputations++;\n      var inputSelectorResults = collectInputSelectorResults(dependencies, arguments);\n      _lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);\n      if (true) {\n        var _getDevModeChecksExec = getDevModeChecksExecutionInfo(firstRun, devModeChecks),\n          identityFunctionCheck = _getDevModeChecksExec.identityFunctionCheck,\n          inputStabilityCheck = _getDevModeChecksExec.inputStabilityCheck;\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(resultFunc, inputSelectorResults, _lastResult2);\n        }\n        if (inputStabilityCheck.shouldRun) {\n          var inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);\n          inputStabilityCheck.run({\n            inputSelectorResults: inputSelectorResults,\n            inputSelectorResultsCopy: inputSelectorResultsCopy\n          }, {\n            memoize: memoize,\n            memoizeOptions: finalMemoizeOptions\n          }, arguments);\n        }\n        if (firstRun) firstRun = false;\n      }\n      return _lastResult2;\n    }].concat(_toConsumableArray(finalArgsMemoizeOptions)));\n    return Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      dependencyRecomputations: function dependencyRecomputations() {\n        return _dependencyRecomputations;\n      },\n      resetDependencyRecomputations: function resetDependencyRecomputations() {\n        _dependencyRecomputations = 0;\n      },\n      lastResult: function lastResult() {\n        return _lastResult2;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        _recomputations = 0;\n      },\n      memoize: memoize,\n      argsMemoize: argsMemoize\n    });\n  };\n  Object.assign(createSelector2, {\n    withTypes: function withTypes() {\n      return createSelector2;\n    }\n  });\n  return createSelector2;\n}\nvar createSelector = /* @__PURE__ */createSelectorCreator(weakMapMemoize);\n\n// src/createStructuredSelector.ts\nvar createStructuredSelector = Object.assign(function (inputSelectorsObject) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n  assertIsObject(inputSelectorsObject, \"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a \".concat(_typeof(inputSelectorsObject)));\n  var inputSelectorKeys = Object.keys(inputSelectorsObject);\n  var dependencies = inputSelectorKeys.map(function (key) {\n    return inputSelectorsObject[key];\n  });\n  var structuredSelector = selectorCreator(dependencies, function () {\n    for (var _len3 = arguments.length, inputSelectorResults = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n      inputSelectorResults[_key7] = arguments[_key7];\n    }\n    return inputSelectorResults.reduce(function (composition, value, index) {\n      composition[inputSelectorKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return structuredSelector;\n}, {\n  withTypes: function withTypes() {\n    return createStructuredSelector;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZGlzdC9yZXNlbGVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFJQSx3QkFBd0IsR0FBRyxTQUEzQkEsd0JBQXdCQSxDQUFJQyxVQUFVLEVBQUVDLHFCQUFxQixFQUFFQyxvQkFBb0IsRUFBSztFQUMxRixJQUFJRCxxQkFBcUIsQ0FBQ0UsTUFBTSxLQUFLLENBQUMsSUFBSUYscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEtBQUtDLG9CQUFvQixFQUFFO0lBQzNGLElBQUlFLG1CQUFtQixHQUFHLEtBQUs7SUFDL0IsSUFBSTtNQUNGLElBQU1DLFdBQVcsR0FBRyxDQUFDLENBQUM7TUFDdEIsSUFBSUwsVUFBVSxDQUFDSyxXQUFXLENBQUMsS0FBS0EsV0FBVyxFQUN6Q0QsbUJBQW1CLEdBQUcsSUFBSTtJQUM5QixDQUFDLENBQUMsT0FBQUUsT0FBQSxFQUFNLENBQ1I7SUFDQSxJQUFJRixtQkFBbUIsRUFBRTtNQUN2QixJQUFJRyxLQUFLLEdBQUcsS0FBSyxDQUFDO01BQ2xCLElBQUk7UUFDRixNQUFNLElBQUlDLEtBQUssQ0FBQyxDQUFDO01BQ25CLENBQUMsQ0FBQyxPQUFPQyxDQUFDLEVBQUU7UUFDVjtRQUNHRixLQUFLLEdBQUtFLENBQUMsQ0FBWEYsS0FBSztNQUNWO01BQ0FHLE9BQU8sQ0FBQ0MsSUFBSSxDQUNWLGlUQUFpVCxFQUNqVDtRQUFFSixLQUFLLEVBQUxBO01BQU0sQ0FDVixDQUFDO0lBQ0g7RUFDRjtBQUNGLENBQUM7O0FBRUQ7QUFDQSxJQUFJSyxzQkFBc0IsR0FBRyxTQUF6QkEsc0JBQXNCQSxDQUFJQywwQkFBMEIsRUFBRUMsT0FBTyxFQUFFQyxpQkFBaUIsRUFBSztFQUN2RixJQUFRQyxPQUFPLEdBQXFCRixPQUFPLENBQW5DRSxPQUFPO0lBQUVDLGNBQWMsR0FBS0gsT0FBTyxDQUExQkcsY0FBYztFQUMvQixJQUFRQyxvQkFB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LEdBQUcsQ0FDeEMsVUFBQzhCLEdBQUc7SUFBQSxPQUFLZ0wsb0JBQW9CLENBQUNoTCxHQUFHLENBQUM7RUFBQSxDQUNwQyxDQUFDO0VBQ0QsSUFBTW9MLGtCQUFrQixHQUFHSCxlQUFlLENBQ3hDdk0sWUFBWSxFQUNaLFlBQTZCO0lBQUEsU0FBQTJNLEtBQUEsR0FBQTVPLFNBQUEsQ0FBQXRCLE1BQUEsRUFBekJlLG9CQUFvQixPQUFBb0MsS0FBQSxDQUFBK00sS0FBQSxHQUFBQyxLQUFBLE1BQUFBLEtBQUEsR0FBQUQsS0FBQSxFQUFBQyxLQUFBO01BQXBCcFAsb0JBQW9CLENBQUFvUCxLQUFBLElBQUE3TyxTQUFBLENBQUE2TyxLQUFBO0lBQUE7SUFDdEIsT0FBT3BQLG9CQUFvQixDQUFDcVAsTUFBTSxDQUFDLFVBQUNDLFdBQVcsRUFBRWxMLEtBQUssRUFBRW1MLEtBQUssRUFBSztNQUNoRUQsV0FBVyxDQUFDTixpQkFBaUIsQ0FBQ08sS0FBSyxDQUFDLENBQUMsR0FBR25MLEtBQUs7TUFDN0MsT0FBT2tMLFdBQVc7SUFDcEIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ1IsQ0FDRixDQUFDO0VBQ0QsT0FBT0osa0JBQWtCO0FBQzNCLENBQUMsRUFDRDtFQUFFUCxTQUFTLEVBQUUsU0FBQUEsVUFBQTtJQUFBLE9BQU1FLHdCQUF3QjtFQUFBO0FBQUMsQ0FDOUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpdGUtcmVhY3QtdHlwZXNjcmlwdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2Rpc3QvcmVzZWxlY3QubWpzPzQwOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Rldk1vZGVDaGVja3MvaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnRzXG52YXIgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKHJlc3VsdEZ1bmMsIGlucHV0U2VsZWN0b3JzUmVzdWx0cywgb3V0cHV0U2VsZWN0b3JSZXN1bHQpID0+IHtcbiAgaWYgKGlucHV0U2VsZWN0b3JzUmVzdWx0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRTZWxlY3RvcnNSZXN1bHRzWzBdID09PSBvdXRwdXRTZWxlY3RvclJlc3VsdCkge1xuICAgIGxldCBpc0lucHV0U2FtZUFzT3V0cHV0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG4gICAgICBpZiAocmVzdWx0RnVuYyhlbXB0eU9iamVjdCkgPT09IGVtcHR5T2JqZWN0KVxuICAgICAgICBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGlzSW5wdXRTYW1lQXNPdXRwdXQpIHtcbiAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICA7XG4gICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zXSwgdG9kb3MgPT4gdG9kb3MpYFxcblRoaXMgY291bGQgbGVhZCB0byBpbmVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy5cXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy5cIixcbiAgICAgICAgeyBzdGFjayB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Rldk1vZGVDaGVja3MvaW5wdXRTdGFiaWxpdHlDaGVjay50c1xudmFyIHJ1bklucHV0U3RhYmlsaXR5Q2hlY2sgPSAoaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3QsIG9wdGlvbnMsIGlucHV0U2VsZWN0b3JBcmdzKSA9PiB7XG4gIGNvbnN0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9ID0gaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3Q7XG4gIGNvbnN0IGNyZWF0ZUFuRW1wdHlPYmplY3QgPSBtZW1vaXplKCgpID0+ICh7fSksIC4uLm1lbW9pemVPcHRpb25zKTtcbiAgY29uc3QgYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCA9IGNyZWF0ZUFuRW1wdHlPYmplY3QuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpID09PSBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSk7XG4gIGlmICghYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCkge1xuICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgO1xuICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkFuIGlucHV0IHNlbGVjdG9yIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIHBhc3NlZCBzYW1lIGFyZ3VtZW50cy5cXG5UaGlzIG1lYW5zIHlvdXIgb3V0cHV0IHNlbGVjdG9yIHdpbGwgbGlrZWx5IHJ1biBtb3JlIGZyZXF1ZW50bHkgdGhhbiBpbnRlbmRlZC5cXG5Bdm9pZCByZXR1cm5pbmcgYSBuZXcgcmVmZXJlbmNlIGluc2lkZSB5b3VyIGlucHV0IHNlbGVjdG9yLCBlLmcuXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKV0sIHRvZG9JZHMgPT4gdG9kb0lkcy5sZW5ndGgpYFwiLFxuICAgICAge1xuICAgICAgICBhcmd1bWVudHM6IGlucHV0U2VsZWN0b3JBcmdzLFxuICAgICAgICBmaXJzdElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHMsXG4gICAgICAgIHNlY29uZElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5LFxuICAgICAgICBzdGFja1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MudHNcbnZhciBnbG9iYWxEZXZNb2RlQ2hlY2tzID0ge1xuICBpbnB1dFN0YWJpbGl0eUNoZWNrOiBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm9uY2VcIlxufTtcbnZhciBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzID0gKGRldk1vZGVDaGVja3MpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxEZXZNb2RlQ2hlY2tzLCBkZXZNb2RlQ2hlY2tzKTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIE5PVF9GT1VORCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXCJOT1RfRk9VTkRcIik7XG5mdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKGZ1bmMsIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIGZ1bmN9YCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNPYmplY3Qob2JqZWN0LCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYW4gb2JqZWN0LCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIG9iamVjdH1gKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoYXJyYXksIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGApIHtcbiAgaWYgKCFhcnJheS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBhcnJheS5tYXAoXG4gICAgICAoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiA/IGBmdW5jdGlvbiAke2l0ZW0ubmFtZSB8fCBcInVubmFtZWRcIn0oKWAgOiB0eXBlb2YgaXRlbVxuICAgICkuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfVske2l0ZW1UeXBlc31dYCk7XG4gIH1cbn1cbnZhciBlbnN1cmVJc0FycmF5ID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dO1xufTtcbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShjcmVhdGVTZWxlY3RvckFyZ3NbMF0pID8gY3JlYXRlU2VsZWN0b3JBcmdzWzBdIDogY3JlYXRlU2VsZWN0b3JBcmdzO1xuICBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYFxuICApO1xuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuZnVuY3Rpb24gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKGRlcGVuZGVuY2llcywgaW5wdXRTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlcGVuZGVuY2llcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JBcmdzKSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzO1xufVxudmFyIGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKGZpcnN0UnVuLCBkZXZNb2RlQ2hlY2tzKSA9PiB7XG4gIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSB7XG4gICAgLi4uZ2xvYmFsRGV2TW9kZUNoZWNrcyxcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiB7XG4gICAgICBzaG91bGRSdW46IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLFxuICAgICAgcnVuOiBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9LFxuICAgIGlucHV0U3RhYmlsaXR5Q2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjogaW5wdXRTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpbnB1dFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bixcbiAgICAgIHJ1bjogcnVuSW5wdXRTdGFiaWxpdHlDaGVja1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja2luZy50c1xudmFyICRSRVZJU0lPTiA9IDA7XG52YXIgQ1VSUkVOVF9UUkFDS0VSID0gbnVsbDtcbnZhciBDZWxsID0gY2xhc3Mge1xuICByZXZpc2lvbiA9ICRSRVZJU0lPTjtcbiAgX3ZhbHVlO1xuICBfbGFzdFZhbHVlO1xuICBfaXNFcXVhbCA9IHRyaXBsZUVxO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUsIGlzRXF1YWwgPSB0cmlwbGVFcSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2lzRXF1YWwgPSBpc0VxdWFsO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyByZWFkLCBpdCdsbCBhZGQgaXRzZWxmIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIgaWZcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxuICBnZXQgdmFsdWUoKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyB1cGRhdGVkLCB3ZSBidW1wIHRoZSBnbG9iYWwgcmV2aXNpb24gY2xvY2ssXG4gIC8vIGFzc2lnbiB0aGUgcmV2aXNpb24gZm9yIHRoaXMgc3RvcmFnZSB0byB0aGUgbmV3IHZhbHVlLCBfYW5kXyB3ZSBzY2hlZHVsZSBhXG4gIC8vIHJlcmVuZGVyLiBUaGlzIGlzIGltcG9ydGFudCwgYW5kIGl0J3Mgd2hhdCBtYWtlcyBhdXRvdHJhY2tpbmcgIF9wdWxsX1xuICAvLyBiYXNlZC4gV2UgZG9uJ3QgYWN0aXZlbHkgdGVsbCB0aGUgY2FjaGVzIHdoaWNoIGRlcGVuZCBvbiB0aGUgc3RvcmFnZSB0aGF0XG4gIC8vIGFueXRoaW5nIGhhcyBoYXBwZW5lZC4gSW5zdGVhZCwgd2UgcmVjb21wdXRlIHRoZSBjYWNoZXMgd2hlbiBuZWVkZWQuXG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBuZXdWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyaXBsZUVxKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgVHJhY2tpbmdDYWNoZSA9IGNsYXNzIHtcbiAgX2NhY2hlZFZhbHVlO1xuICBfY2FjaGVkUmV2aXNpb24gPSAtMTtcbiAgX2RlcHMgPSBbXTtcbiAgaGl0cyA9IDA7XG4gIGZuO1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IC0xO1xuICAgIHRoaXMuX2RlcHMgPSBbXTtcbiAgICB0aGlzLmhpdHMgPSAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5yZXZpc2lvbiA+IHRoaXMuX2NhY2hlZFJldmlzaW9uKSB7XG4gICAgICBjb25zdCB7IGZuIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgcHJldlRyYWNrZXIgPSBDVVJSRU5UX1RSQUNLRVI7XG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBjdXJyZW50VHJhY2tlcjtcbiAgICAgIHRoaXMuX2NhY2hlZFZhbHVlID0gZm4oKTtcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IHByZXZUcmFja2VyO1xuICAgICAgdGhpcy5oaXRzKys7XG4gICAgICB0aGlzLl9kZXBzID0gQXJyYXkuZnJvbShjdXJyZW50VHJhY2tlcik7XG4gICAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IHRoaXMucmV2aXNpb247XG4gICAgfVxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRWYWx1ZTtcbiAgfVxuICBnZXQgcmV2aXNpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuX2RlcHMubWFwKChkKSA9PiBkLnJldmlzaW9uKSwgMCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRWYWx1ZShjZWxsKSB7XG4gIGlmICghKGNlbGwgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIGNlbGwhIFwiLCBjZWxsKTtcbiAgfVxuICByZXR1cm4gY2VsbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlKHN0b3JhZ2UsIHZhbHVlKSB7XG4gIGlmICghKHN0b3JhZ2UgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcInNldFZhbHVlIG11c3QgYmUgcGFzc2VkIGEgdHJhY2tlZCBzdG9yZSBjcmVhdGVkIHdpdGggYGNyZWF0ZVN0b3JhZ2VgLlwiXG4gICAgKTtcbiAgfVxuICBzdG9yYWdlLnZhbHVlID0gc3RvcmFnZS5fbGFzdFZhbHVlID0gdmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoZm4pIHtcbiAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICBmbixcbiAgICBcInRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gYGNyZWF0ZUNhY2hlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIlxuICApO1xuICByZXR1cm4gbmV3IFRyYWNraW5nQ2FjaGUoZm4pO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS90cmFja2luZy50c1xudmFyIG5ldmVyRXEgPSAoYSwgYikgPT4gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVUYWcoKSB7XG4gIHJldHVybiBjcmVhdGVDZWxsKG51bGwsIG5ldmVyRXEpO1xufVxuZnVuY3Rpb24gZGlydHlUYWcodGFnLCB2YWx1ZSkge1xuICBzZXRWYWx1ZSh0YWcsIHZhbHVlKTtcbn1cbnZhciBjb25zdW1lQ29sbGVjdGlvbiA9IChub2RlKSA9PiB7XG4gIGxldCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKTtcbiAgfVxuICBnZXRWYWx1ZSh0YWcpO1xufTtcbnZhciBkaXJ0eUNvbGxlY3Rpb24gPSAobm9kZSkgPT4ge1xuICBjb25zdCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICBkaXJ0eVRhZyh0YWcsIG51bGwpO1xuICB9XG59O1xuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9wcm94eS50c1xudmFyIFJFRFVYX1BST1hZX0xBQkVMID0gU3ltYm9sKCk7XG52YXIgbmV4dElkID0gMDtcbnZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG52YXIgT2JqZWN0VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIG9iamVjdFByb3h5SGFuZGxlcik7XG4gIHRhZyA9IGNyZWF0ZVRhZygpO1xuICB0YWdzID0ge307XG4gIGNoaWxkcmVuID0ge307XG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsO1xuICBpZCA9IG5leHRJZCsrO1xufTtcbnZhciBvYmplY3RQcm94eUhhbmRsZXIgPSB7XG4gIGdldChub2RlLCBrZXkpIHtcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoKSB7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgICAgY29uc3QgY2hpbGRWYWx1ZSA9IFJlZmxlY3QuZ2V0KHZhbHVlLCBrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5IGluIHByb3RvKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5ba2V5XTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldID0gY3JlYXRlTm9kZShjaGlsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLnRhZykge1xuICAgICAgICAgIGdldFZhbHVlKGNoaWxkTm9kZS50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUucHJveHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGFnID0gbm9kZS50YWdzW2tleV07XG4gICAgICAgIGlmICh0YWcgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRhZyA9IG5vZGUudGFnc1trZXldID0gY3JlYXRlVGFnKCk7XG4gICAgICAgICAgdGFnLnZhbHVlID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSh0YWcpO1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gY2FsY3VsYXRlUmVzdWx0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgb3duS2V5cyhub2RlKSB7XG4gICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhub2RlLnZhbHVlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS52YWx1ZSwgcHJvcCk7XG4gIH0sXG4gIGhhcyhub2RlLCBwcm9wKSB7XG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApO1xuICB9XG59O1xudmFyIEFycmF5VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KFt0aGlzXSwgYXJyYXlQcm94eUhhbmRsZXIpO1xuICB0YWcgPSBjcmVhdGVUYWcoKTtcbiAgdGFncyA9IHt9O1xuICBjaGlsZHJlbiA9IHt9O1xuICBjb2xsZWN0aW9uVGFnID0gbnVsbDtcbiAgaWQgPSBuZXh0SWQrKztcbn07XG52YXIgYXJyYXlQcm94eUhhbmRsZXIgPSB7XG4gIGdldChbbm9kZV0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmdldChub2RlLCBrZXkpO1xuICB9LFxuICBvd25LZXlzKFtub2RlXSkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIub3duS2V5cyhub2RlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFtub2RlXSwgcHJvcCkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApO1xuICB9LFxuICBoYXMoW25vZGVdLCBwcm9wKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5oYXMobm9kZSwgcHJvcCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlUcmVlTm9kZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPYmplY3RUcmVlTm9kZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHsgdmFsdWUsIHRhZ3MsIGNoaWxkcmVuIH0gPSBub2RlO1xuICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xuICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBsZXQgb2xkS2V5c1NpemUgPSAwO1xuICAgICAgbGV0IG5ld0tleXNTaXplID0gMDtcbiAgICAgIGxldCBhbnlLZXlzQWRkZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgX2tleSBpbiB2YWx1ZSkge1xuICAgICAgICBvbGRLZXlzU2l6ZSsrO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgbmV3S2V5c1NpemUrKztcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgIGFueUtleXNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gYW55S2V5c0FkZGVkIHx8IG9sZEtleXNTaXplICE9PSBuZXdLZXlzU2l6ZTtcbiAgICAgIGlmIChpc0RpZmZlcmVudCkge1xuICAgICAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHRhZ3MpIHtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gdmFsdWVba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBpZiAoY2hpbGRWYWx1ZSAhPT0gbmV3Q2hpbGRWYWx1ZSkge1xuICAgICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICAgICAgZGlydHlUYWcodGFnc1trZXldLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0YWdzW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5ba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gY2hpbGROb2RlLnZhbHVlO1xuICAgIGlmIChjaGlsZFZhbHVlID09PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZU5vZGUoY2hpbGROb2RlLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlTm9kZShjaGlsZE5vZGUpO1xuICAgICAgZGVsZXRlIGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWxldGVOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUudGFnKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWcsIG51bGwpO1xuICB9XG4gIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS50YWdzKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuY2hpbGRyZW4pIHtcbiAgICBkZWxldGVOb2RlKG5vZGUuY2hpbGRyZW5ba2V5XSk7XG4gIH1cbn1cblxuLy8gc3JjL2xydU1lbW9pemUudHNcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGVxdWFscykge1xuICBsZXQgZW50cnk7XG4gIHJldHVybiB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgICB9LFxuICAgIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICBlbnRyeSA9IHsga2V5LCB2YWx1ZSB9O1xuICAgIH0sXG4gICAgZ2V0RW50cmllcygpIHtcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgZXF1YWxzKSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBjb25zdCBjYWNoZUluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoKGVudHJ5KSA9PiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpKTtcbiAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF07XG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cbiAgZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAoZ2V0KGtleSkgPT09IE5PVF9GT1VORCkge1xuICAgICAgZW50cmllcy51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnRyaWVzID0gW107XG4gIH1cbiAgcmV0dXJuIHsgZ2V0LCBwdXQsIGdldEVudHJpZXMsIGNsZWFyIH07XG59XG52YXIgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayA9IChhLCBiKSA9PiBhID09PSBiO1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gcHJldjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxydU1lbW9pemUoZnVuYywgZXF1YWxpdHlDaGVja09yT3B0aW9ucykge1xuICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPSB0eXBlb2YgZXF1YWxpdHlDaGVja09yT3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7IGVxdWFsaXR5Q2hlY2s6IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgfTtcbiAgY29uc3Qge1xuICAgIGVxdWFsaXR5Q2hlY2sgPSByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxuICAgIG1heFNpemUgPSAxLFxuICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2tcbiAgfSA9IHByb3ZpZGVkT3B0aW9ucztcbiAgY29uc3QgY29tcGFyYXRvciA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKTtcbiAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XG4gIGNvbnN0IGNhY2hlID0gbWF4U2l6ZSA8PSAxID8gY3JlYXRlU2luZ2xldG9uQ2FjaGUoY29tcGFyYXRvcikgOiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBjb21wYXJhdG9yKTtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgbGV0IHZhbHVlID0gY2FjaGUuZ2V0KGFyZ3VtZW50cyk7XG4gICAgaWYgKHZhbHVlID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIHZhbHVlID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgcmVzdWx0c0NvdW50Kys7XG4gICAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gY2FjaGUuZ2V0RW50cmllcygpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKFxuICAgICAgICAgIChlbnRyeSkgPT4gcmVzdWx0RXF1YWxpdHlDaGVjayhlbnRyeS52YWx1ZSwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUucHV0KGFyZ3VtZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICBjYWNoZS5jbGVhcigpO1xuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KCk7XG4gIH07XG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudDtcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XG4gICAgcmVzdWx0c0NvdW50ID0gMDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9hdXRvdHJhY2tNZW1vaXplLnRzXG5mdW5jdGlvbiBhdXRvdHJhY2tNZW1vaXplKGZ1bmMpIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUoXG4gICAgW11cbiAgKTtcbiAgbGV0IGxhc3RBcmdzID0gbnVsbDtcbiAgY29uc3Qgc2hhbGxvd0VxdWFsID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2spO1xuICBjb25zdCBjYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IHtcbiAgICBjb25zdCByZXMgPSBmdW5jLmFwcGx5KG51bGwsIG5vZGUucHJveHkpO1xuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChsYXN0QXJncywgYXJndW1lbnRzKSkge1xuICAgICAgdXBkYXRlTm9kZShub2RlLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgfVxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gKCkgPT4ge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIHNyYy93ZWFrTWFwTWVtb2l6ZS50c1xudmFyIFN0cm9uZ1JlZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVyZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG52YXIgUmVmID0gdHlwZW9mIFdlYWtSZWYgIT09IFwidW5kZWZpbmVkXCIgPyBXZWFrUmVmIDogU3Ryb25nUmVmO1xudmFyIFVOVEVSTUlOQVRFRCA9IDA7XG52YXIgVEVSTUlOQVRFRCA9IDE7XG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGUoKSB7XG4gIHJldHVybiB7XG4gICAgczogVU5URVJNSU5BVEVELFxuICAgIHY6IHZvaWQgMCxcbiAgICBvOiBudWxsLFxuICAgIHA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHdlYWtNYXBNZW1vaXplKGZ1bmMsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gIGNvbnN0IHsgcmVzdWx0RXF1YWxpdHlDaGVjayB9ID0gb3B0aW9ucztcbiAgbGV0IGxhc3RSZXN1bHQ7XG4gIGxldCByZXN1bHRzQ291bnQgPSAwO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBsZXQgY2FjaGVOb2RlID0gZm5Ob2RlO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhcmd1bWVudHM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiAmJiBhcmcgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IG9iamVjdENhY2hlID0gY2FjaGVOb2RlLm87XG4gICAgICAgIGlmIChvYmplY3RDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5vID0gb2JqZWN0Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3ROb2RlID0gb2JqZWN0Q2FjaGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChvYmplY3ROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgICAgICBvYmplY3RDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IG9iamVjdE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmltaXRpdmVDYWNoZSA9IGNhY2hlTm9kZS5wO1xuICAgICAgICBpZiAocHJpbWl0aXZlQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjYWNoZU5vZGUucCA9IHByaW1pdGl2ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmltaXRpdmVOb2RlID0gcHJpbWl0aXZlQ2FjaGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChwcmltaXRpdmVOb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgICAgICBwcmltaXRpdmVDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IHByaW1pdGl2ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZE5vZGUgPSBjYWNoZU5vZGU7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IFRFUk1JTkFURUQpIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlTm9kZS52O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXN1bHRzQ291bnQrKztcbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXN1bHRWYWx1ZSA9IGxhc3RSZXN1bHQ/LmRlcmVmPy4oKSA/PyBsYXN0UmVzdWx0O1xuICAgICAgICBpZiAobGFzdFJlc3VsdFZhbHVlICE9IG51bGwgJiYgcmVzdWx0RXF1YWxpdHlDaGVjayhsYXN0UmVzdWx0VmFsdWUsIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBsYXN0UmVzdWx0VmFsdWU7XG4gICAgICAgICAgcmVzdWx0c0NvdW50ICE9PSAwICYmIHJlc3VsdHNDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRzV2Vha1JlZiA9IHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgcmVzdWx0ICE9PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgbGFzdFJlc3VsdCA9IG5lZWRzV2Vha1JlZiA/IG5ldyBSZWYocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGVybWluYXRlZE5vZGUucyA9IFRFUk1JTkFURUQ7XG4gICAgdGVybWluYXRlZE5vZGUudiA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gICAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQoKTtcbiAgfTtcbiAgbWVtb2l6ZWQucmVzdWx0c0NvdW50ID0gKCkgPT4gcmVzdWx0c0NvdW50O1xuICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCA9ICgpID0+IHtcbiAgICByZXN1bHRzQ291bnQgPSAwO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIHNyYy9jcmVhdGVTZWxlY3RvckNyZWF0b3IudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcihtZW1vaXplT3JPcHRpb25zLCAuLi5tZW1vaXplT3B0aW9uc0Zyb21BcmdzKSB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnMgPSB0eXBlb2YgbWVtb2l6ZU9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8ge1xuICAgIG1lbW9pemU6IG1lbW9pemVPck9wdGlvbnMsXG4gICAgbWVtb2l6ZU9wdGlvbnM6IG1lbW9pemVPcHRpb25zRnJvbUFyZ3NcbiAgfSA6IG1lbW9pemVPck9wdGlvbnM7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9ICguLi5jcmVhdGVTZWxlY3RvckFyZ3MpID0+IHtcbiAgICBsZXQgcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIGxldCBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIGxldCBsYXN0UmVzdWx0O1xuICAgIGxldCBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSB7fTtcbiAgICBsZXQgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmM7XG4gICAgICByZXN1bHRGdW5jID0gY3JlYXRlU2VsZWN0b3JBcmdzLnBvcCgpO1xuICAgIH1cbiAgICBhc3NlcnRJc0Z1bmN0aW9uKFxuICAgICAgcmVzdWx0RnVuYyxcbiAgICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFuIG91dHB1dCBmdW5jdGlvbiBhZnRlciB0aGUgaW5wdXRzLCBidXQgcmVjZWl2ZWQ6IFske3R5cGVvZiByZXN1bHRGdW5jfV1gXG4gICAgKTtcbiAgICBjb25zdCBjb21iaW5lZE9wdGlvbnMgPSB7XG4gICAgICAuLi5jcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zLFxuICAgICAgLi4uZGlyZWN0bHlQYXNzZWRPcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBtZW1vaXplLFxuICAgICAgbWVtb2l6ZU9wdGlvbnMgPSBbXSxcbiAgICAgIGFyZ3NNZW1vaXplID0gd2Vha01hcE1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZU9wdGlvbnMgPSBbXSxcbiAgICAgIGRldk1vZGVDaGVja3MgPSB7fVxuICAgIH0gPSBjb21iaW5lZE9wdGlvbnM7XG4gICAgY29uc3QgZmluYWxNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpO1xuICAgIGNvbnN0IGZpbmFsQXJnc01lbW9pemVPcHRpb25zID0gZW5zdXJlSXNBcnJheShhcmdzTWVtb2l6ZU9wdGlvbnMpO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpO1xuICAgIGNvbnN0IG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUoZnVuY3Rpb24gcmVjb21wdXRhdGlvbldyYXBwZXIoKSB7XG4gICAgICByZWNvbXB1dGF0aW9ucysrO1xuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKTtcbiAgICB9LCAuLi5maW5hbE1lbW9pemVPcHRpb25zKTtcbiAgICBsZXQgZmlyc3RSdW4gPSB0cnVlO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYXJnc01lbW9pemUoZnVuY3Rpb24gZGVwZW5kZW5jaWVzQ2hlY2tlcigpIHtcbiAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucysrO1xuICAgICAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXG4gICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICApO1xuICAgICAgbGFzdFJlc3VsdCA9IG1lbW9pemVkUmVzdWx0RnVuYy5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSBnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mbyhmaXJzdFJ1biwgZGV2TW9kZUNoZWNrcyk7XG4gICAgICAgIGlmIChpZGVudGl0eUZ1bmN0aW9uQ2hlY2suc2hvdWxkUnVuKSB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnJ1bihcbiAgICAgICAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICAgICAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFN0YWJpbGl0eUNoZWNrLnNob3VsZFJ1bikge1xuICAgICAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSA9IGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXRTdGFiaWxpdHlDaGVjay5ydW4oXG4gICAgICAgICAgICB7IGlucHV0U2VsZWN0b3JSZXN1bHRzLCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgfSxcbiAgICAgICAgICAgIHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnM6IGZpbmFsTWVtb2l6ZU9wdGlvbnMgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0UnVuKVxuICAgICAgICAgIGZpcnN0UnVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9LCAuLi5maW5hbEFyZ3NNZW1vaXplT3B0aW9ucyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2VsZWN0b3IsIHtcbiAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICBtZW1vaXplZFJlc3VsdEZ1bmMsXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyxcbiAgICAgIHJlc2V0RGVwZW5kZW5jeVJlY29tcHV0YXRpb25zOiAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgICB9LFxuICAgICAgbGFzdFJlc3VsdDogKCkgPT4gbGFzdFJlc3VsdCxcbiAgICAgIHJlY29tcHV0YXRpb25zOiAoKSA9PiByZWNvbXB1dGF0aW9ucyxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfSxcbiAgICAgIG1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZVxuICAgIH0pO1xuICB9O1xuICBPYmplY3QuYXNzaWduKGNyZWF0ZVNlbGVjdG9yMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlU2VsZWN0b3IyO1xufVxudmFyIGNyZWF0ZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IudHNcbnZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKFxuICAoaW5wdXRTZWxlY3RvcnNPYmplY3QsIHNlbGVjdG9yQ3JlYXRvciA9IGNyZWF0ZVNlbGVjdG9yKSA9PiB7XG4gICAgYXNzZXJ0SXNPYmplY3QoXG4gICAgICBpbnB1dFNlbGVjdG9yc09iamVjdCxcbiAgICAgIGBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgZXhwZWN0cyBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgJHt0eXBlb2YgaW5wdXRTZWxlY3RvcnNPYmplY3R9YFxuICAgICk7XG4gICAgY29uc3QgaW5wdXRTZWxlY3RvcktleXMgPSBPYmplY3Qua2V5cyhpbnB1dFNlbGVjdG9yc09iamVjdCk7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gaW5wdXRTZWxlY3RvcktleXMubWFwKFxuICAgICAgKGtleSkgPT4gaW5wdXRTZWxlY3RvcnNPYmplY3Rba2V5XVxuICAgICk7XG4gICAgY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgKC4uLmlucHV0U2VsZWN0b3JSZXN1bHRzKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnB1dFNlbGVjdG9yUmVzdWx0cy5yZWR1Y2UoKGNvbXBvc2l0aW9uLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb21wb3NpdGlvbltpbnB1dFNlbGVjdG9yS2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gc3RydWN0dXJlZFNlbGVjdG9yO1xuICB9LFxuICB7IHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH1cbik7XG5leHBvcnQge1xuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IsXG4gIGxydU1lbW9pemUsXG4gIHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXG4gIHNldEdsb2JhbERldk1vZGVDaGVja3MsXG4gIGF1dG90cmFja01lbW9pemUgYXMgdW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSxcbiAgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNlbGVjdC5tanMubWFwIl0sIm5hbWVzIjpbInJ1bklkZW50aXR5RnVuY3Rpb25DaGVjayIsInJlc3VsdEZ1bmMiLCJpbnB1dFNlbGVjdG9yc1Jlc3VsdHMiLCJvdXRwdXRTZWxlY3RvclJlc3VsdCIsImxlbmd0aCIsImlzSW5wdXRTYW1lQXNPdXRwdXQiLCJlbXB0eU9iamVjdCIsIl91bnVzZWQiLCJzdGFjayIsIkVycm9yIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwicnVuSW5wdXRTdGFiaWxpdHlDaGVjayIsImlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0Iiwib3B0aW9ucyIsImlucHV0U2VsZWN0b3JBcmdzIiwibWVtb2l6ZSIsIm1lbW9pemVPcHRpb25zIiwiaW5wdXRTZWxlY3RvclJlc3VsdHMiLCJpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkiLCJjcmVhdGVBbkVtcHR5T2JqZWN0IiwiYXBwbHkiLCJjb25jYXQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcmVJbnB1dFNlbGVjdG9yUmVzdWx0c0VxdWFsIiwiYXJndW1lbnRzIiwiZmlyc3RJbnB1dHMiLCJzZWNvbmRJbnB1dHMiLCJnbG9iYWxEZXZNb2RlQ2hlY2tzIiwiaW5wdXRTdGFiaWxpdHlDaGVjayIsImlkZW50aXR5RnVuY3Rpb25DaGVjayIsInNldEdsb2JhbERldk1vZGVDaGVja3MiLCJkZXZNb2RlQ2hlY2tzIiwiT2JqZWN0IiwiYXNzaWduIiwiTk9UX0ZPVU5EIiwiU3ltYm9sIiwiYXNzZXJ0SXNGdW5jdGlvbiIsImZ1bmMiLCJlcnJvck1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJfdHlwZW9mIiwiVHlwZUVycm9yIiwiYXNzZXJ0SXNPYmplY3QiLCJvYmplY3QiLCJhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMiLCJhcnJheSIsImV2ZXJ5IiwiaXRlbSIsIml0ZW1UeXBlcyIsIm1hcCIsIm5hbWUiLCJqb2luIiwiZW5zdXJlSXNBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImdldERlcGVuZGVuY2llcyIsImNyZWF0ZVNlbGVjdG9yQXJncyIsImRlcGVuZGVuY2llcyIsImNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyIsImkiLCJwdXNoIiwiZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8iLCJmaXJzdFJ1biIsIl9nbG9iYWxEZXZNb2RlQ2hlY2tzJCIsIl9vYmplY3RTcHJlYWQiLCJzaG91bGRSdW4iLCJydW4iLCIkUkVWSVNJT04iLCJDVVJSRU5UX1RSQUNLRVIiLCJDZWxsIiwiaW5pdGlhbFZhbHVlIiwiaXNFcXVhbCIsInRyaXBsZUVxIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2RlZmluZVByb3BlcnR5IiwiX3ZhbHVlIiwiX2xhc3RWYWx1ZSIsIl9pc0VxdWFsIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwiZ2V0IiwiX0NVUlJFTlRfVFJBQ0tFUiIsImFkZCIsInNldCIsIm5ld1ZhbHVlIiwidmFsdWUiLCJyZXZpc2lvbiIsImEiLCJiIiwiVHJhY2tpbmdDYWNoZSIsImZuIiwiY2xlYXIiLCJfY2FjaGVkVmFsdWUiLCJfY2FjaGVkUmV2aXNpb24iLCJfZGVwcyIsImhpdHMiLCJfQ1VSUkVOVF9UUkFDS0VSMiIsImN1cnJlbnRUcmFja2VyIiwiU2V0IiwicHJldlRyYWNrZXIiLCJmcm9tIiwiTWF0aCIsIm1heCIsImQiLCJnZXRWYWx1ZSIsImNlbGwiLCJzZXRWYWx1ZSIsInN0b3JhZ2UiLCJjcmVhdGVDZWxsIiwiY3JlYXRlQ2FjaGUiLCJuZXZlckVxIiwiY3JlYXRlVGFnIiwiZGlydHlUYWciLCJ0YWciLCJjb25zdW1lQ29sbGVjdGlvbiIsIm5vZGUiLCJjb2xsZWN0aW9uVGFnIiwiZGlydHlDb2xsZWN0aW9uIiwiUkVEVVhfUFJPWFlfTEFCRUwiLCJuZXh0SWQiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiT2JqZWN0VHJlZU5vZGUiLCJQcm94eSIsIm9iamVjdFByb3h5SGFuZGxlciIsImNhbGN1bGF0ZVJlc3VsdCIsImNoaWxkVmFsdWUiLCJSZWZsZWN0IiwiY2hpbGROb2RlIiwiY2hpbGRyZW4iLCJjcmVhdGVOb2RlIiwicHJveHkiLCJ0YWdzIiwicmVzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInByb3AiLCJoYXMiLCJBcnJheVRyZWVOb2RlIiwiYXJyYXlQcm94eUhhbmRsZXIiLCJfcmVmIiwiX3JlZjIiLCJfc2xpY2VkVG9BcnJheSIsIl9yZWYzIiwiX3JlZjQiLCJfcmVmNSIsIl9yZWY2IiwiX3JlZjciLCJfcmVmOCIsInVwZGF0ZU5vZGUiLCJvbGRLZXlzU2l6ZSIsIm5ld0tleXNTaXplIiwiYW55S2V5c0FkZGVkIiwiX2tleSIsImlzRGlmZmVyZW50IiwibmV3Q2hpbGRWYWx1ZSIsImRlbGV0ZU5vZGUiLCJjcmVhdGVTaW5nbGV0b25DYWNoZSIsImVxdWFscyIsImVudHJ5IiwicHV0IiwiZ2V0RW50cmllcyIsImNyZWF0ZUxydUNhY2hlIiwibWF4U2l6ZSIsImVudHJpZXMiLCJjYWNoZUluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwidW5zaGlmdCIsInBvcCIsInJlZmVyZW5jZUVxdWFsaXR5Q2hlY2siLCJjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IiLCJlcXVhbGl0eUNoZWNrIiwiYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwiLCJwcmV2IiwibmV4dCIsImxydU1lbW9pemUiLCJlcXVhbGl0eUNoZWNrT3JPcHRpb25zIiwicHJvdmlkZWRPcHRpb25zIiwiX3Byb3ZpZGVkT3B0aW9ucyRlcXVhIiwiX3Byb3ZpZGVkT3B0aW9ucyRtYXhTIiwicmVzdWx0RXF1YWxpdHlDaGVjayIsImNvbXBhcmF0b3IiLCJyZXN1bHRzQ291bnQiLCJjYWNoZSIsIm1lbW9pemVkIiwibWF0Y2hpbmdFbnRyeSIsImZpbmQiLCJjbGVhckNhY2hlIiwicmVzZXRSZXN1bHRzQ291bnQiLCJhdXRvdHJhY2tNZW1vaXplIiwibGFzdEFyZ3MiLCJzaGFsbG93RXF1YWwiLCJTdHJvbmdSZWYiLCJkZXJlZiIsIlJlZiIsIldlYWtSZWYiLCJVTlRFUk1JTkFURUQiLCJURVJNSU5BVEVEIiwiY3JlYXRlQ2FjaGVOb2RlIiwicyIsInYiLCJvIiwicCIsIndlYWtNYXBNZW1vaXplIiwiZm5Ob2RlIiwibGFzdFJlc3VsdCIsImNhY2hlTm9kZSIsImwiLCJhcmciLCJvYmplY3RDYWNoZSIsIldlYWtNYXAiLCJvYmplY3ROb2RlIiwicHJpbWl0aXZlQ2FjaGUiLCJNYXAiLCJwcmltaXRpdmVOb2RlIiwidGVybWluYXRlZE5vZGUiLCJyZXN1bHQiLCJfbGFzdFJlc3VsdCRkZXJlZiIsIl9sYXN0UmVzdWx0IiwiX2xhc3RSZXN1bHQkZGVyZWYyIiwibGFzdFJlc3VsdFZhbHVlIiwiY2FsbCIsIm5lZWRzV2Vha1JlZiIsImNyZWF0ZVNlbGVjdG9yQ3JlYXRvciIsIm1lbW9pemVPck9wdGlvbnMiLCJfbGVuIiwibWVtb2l6ZU9wdGlvbnNGcm9tQXJncyIsIl9rZXk1IiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yT3B0aW9ucyIsImNyZWF0ZVNlbGVjdG9yMiIsIl9sZW4yIiwiX2tleTYiLCJyZWNvbXB1dGF0aW9ucyIsImRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyIsImRpcmVjdGx5UGFzc2VkT3B0aW9ucyIsImNvbWJpbmVkT3B0aW9ucyIsIl9jb21iaW5lZE9wdGlvbnMkbWVtbyIsIl9jb21iaW5lZE9wdGlvbnMkYXJncyIsImFyZ3NNZW1vaXplIiwiX2NvbWJpbmVkT3B0aW9ucyRhcmdzMiIsImFyZ3NNZW1vaXplT3B0aW9ucyIsIl9jb21iaW5lZE9wdGlvbnMkZGV2TSIsImZpbmFsTWVtb2l6ZU9wdGlvbnMiLCJmaW5hbEFyZ3NNZW1vaXplT3B0aW9ucyIsIm1lbW9pemVkUmVzdWx0RnVuYyIsInJlY29tcHV0YXRpb25XcmFwcGVyIiwic2VsZWN0b3IiLCJkZXBlbmRlbmNpZXNDaGVja2VyIiwiX2dldERldk1vZGVDaGVja3NFeGVjIiwicmVzZXREZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMiLCJyZXNldFJlY29tcHV0YXRpb25zIiwid2l0aFR5cGVzIiwiY3JlYXRlU2VsZWN0b3IiLCJjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IiLCJpbnB1dFNlbGVjdG9yc09iamVjdCIsInNlbGVjdG9yQ3JlYXRvciIsImlucHV0U2VsZWN0b3JLZXlzIiwia2V5cyIsInN0cnVjdHVyZWRTZWxlY3RvciIsIl9sZW4zIiwiX2tleTciLCJyZWR1Y2UiLCJjb21wb3NpdGlvbiIsImluZGV4IiwidW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reselect/dist/reselect.mjs\n");

/***/ })

};
;