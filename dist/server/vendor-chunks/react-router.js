"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _callSuper(_this, derived, args) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (e) {\n      return false;\n    }\n  }\n  derived = _getPrototypeOf(derived);\n  return _possibleConstructorReturn(_this, isNativeReflectConstruct() ? Reflect.construct(derived, args || [], _getPrototypeOf(_this).constructor) : derived.apply(_this, args));\n}\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n/**\n * React Router v6.24.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nvar DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nvar DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nvar AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  AwaitContext.displayName = \"Await\";\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nvar NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  NavigationContext.displayName = \"Navigation\";\n}\nvar LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  LocationContext.displayName = \"Location\";\n}\nvar RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (true) {\n  RouteContext.displayName = \"Route\";\n}\nvar RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  var _ref9 = _temp === void 0 ? {} : _temp,\n    relative = _ref9.relative;\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext),\n    basename = _React$useContext.basename,\n    navigator = _React$useContext.navigator;\n  var _useResolvedPath = useResolvedPath(to, {\n      relative: relative\n    }),\n    hash = _useResolvedPath.hash,\n    pathname = _useResolvedPath.pathname,\n    search = _useResolvedPath.search;\n  var joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search: search,\n    hash: hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  var _useLocation = useLocation(),\n    pathname = _useLocation.pathname;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname);\n  }, [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nvar navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  var isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext)[\"static\"];\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n  var _React$useContext2 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext),\n    isDataRoute = _React$useContext2.isDataRoute;\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  var dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  var _React$useContext3 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext),\n    basename = _React$useContext3.basename,\n    future = _React$useContext3.future,\n    navigator = _React$useContext3.navigator;\n  var _React$useContext4 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext),\n    matches = _React$useContext4.matches;\n  var _useLocation2 = useLocation(),\n    locationPathname = _useLocation2.pathname;\n  var routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n  var activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    activeRef.current = true;\n  });\n  var navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    var path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we're not in a data router,\n    // otherwise it'll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nvar OutletContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  var outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n  var _React$useContext5 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext),\n    matches = _React$useContext5.matches;\n  var routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  var _ref10 = _temp2 === void 0 ? {} : _temp2,\n    relative = _ref10.relative;\n  var _React$useContext6 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext),\n    future = _React$useContext6.future;\n  var _React$useContext7 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext),\n    matches = _React$useContext7.matches;\n  var _useLocation3 = useLocation(),\n    locationPathname = _useLocation3.pathname;\n  var routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\");\n  }, [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  var _React$useContext8 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext),\n    navigator = _React$useContext8.navigator;\n  var _React$useContext9 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext),\n    parentMatches = _React$useContext9.matches;\n  var routeMatch = parentMatches[parentMatches.length - 1];\n  var parentParams = routeMatch ? routeMatch.params : {};\n  var parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  var parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  var parentRoute = routeMatch && routeMatch.route;\n  if (true) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    var parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n  var locationFromContext = useLocation();\n  var location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    var parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : 0 : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  var pathname = location.pathname || \"/\";\n  var remainingPathname = pathname;\n  if (parentPathnameBase !== \"/\") {\n    // Determine the remaining pathname by removing the # of URL segments the\n    // parentPathnameBase has, instead of removing based on character count.\n    // This is because we can't guarantee that incoming/outgoing encodings/\n    // decodings will match exactly.\n    // We decode paths before matching on a per-segment basis with\n    // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\n    // match what `window.location.pathname` would reflect.  Those don't 100%\n    // align when it comes to encoded URI characters such as % and &.\n    //\n    // So we may end up with:\n    //   pathname:           \"/descendant/a%25b/match\"\n    //   parentPathnameBase: \"/descendant/a%b\"\n    //\n    // And the direct substring removal approach won't work :/\n    var parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n    var segments = pathname.replace(/^\\//, \"\").split(\"/\");\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n  }\n  var matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n    pathname: remainingPathname\n  });\n  if (true) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : 0;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : 0;\n  }\n  var renderedMatches = _renderMatches(matches && matches.map(function (match) {\n    return Object.assign({}, match, {\n      params: Object.assign({}, parentParams, match.params),\n      pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n      pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n    });\n  }), parentMatches, dataRouterState, future);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  var error = useRouteError();\n  var message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  var stack = error instanceof Error ? error.stack : null;\n  var lightgrey = \"rgba(200,200,200, 0.5)\";\n  var preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  var codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  var devInfo = null;\n  if (true) {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  function RenderErrorBoundary(props) {\n    var _this2;\n    _classCallCheck(this, RenderErrorBoundary);\n    _this2 = _callSuper(this, RenderErrorBoundary, [props]);\n    _this2.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n    return _this2;\n  }\n  _inherits(RenderErrorBoundary, _React$Component);\n  return _createClass(RenderErrorBoundary, [{\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(error, errorInfo) {\n      console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.state.error !== undefined ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n        value: this.props.routeContext\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n        value: this.state.error,\n        children: this.props.component\n      })) : this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      // When we get into an error state, the user will likely click \"back\" to the\n      // previous page that didn't have an error. Because this wraps the entire\n      // application, that will have no effect--the error page continues to display.\n      // This gives us a mechanism to recover from the error when the location changes.\n      //\n      // Whether we're in an error state or not, we update the location in state\n      // so that when we are in an error state, it gets reset when a new location\n      // comes in and the user recovers from the error.\n      if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n        return {\n          error: props.error,\n          location: props.location,\n          revalidation: props.revalidation\n        };\n      }\n\n      // If we're not changing locations, preserve the location but still surface\n      // any new errors that may come through. We retain the existing error, we do\n      // this because the error provided from the app state may be cleared without\n      // the location changing.\n      return {\n        error: props.error !== undefined ? props.error : state.error,\n        location: state.location,\n        revalidation: props.revalidation || state.revalidation\n      };\n    }\n  }]);\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nfunction RenderedRoute(_ref) {\n  var routeContext = _ref.routeContext,\n    match = _ref.match,\n    children = _ref.children;\n  var dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext[\"static\"] && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (future === void 0) {\n    future = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  var renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  var errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    var errorIndex = renderedMatches.findIndex(function (m) {\n      return m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined;\n    });\n    !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n\n  // If we're in a partial hydration mode, detect if we need to render down to\n  // a given HydrateFallback while we load the rest of the hydration data\n  var renderFallback = false;\n  var fallbackIndex = -1;\n  if (dataRouterState && future && future.v7_partialHydration) {\n    for (var i = 0; i < renderedMatches.length; i++) {\n      var match = renderedMatches[i];\n      // Track the deepest fallback up until the first route without data\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.id) {\n        var _dataRouterState3 = dataRouterState,\n          loaderData = _dataRouterState3.loaderData,\n          _errors = _dataRouterState3.errors;\n        var needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!_errors || _errors[match.route.id] === undefined);\n        if (match.route.lazy || needsToRunLoader) {\n          // We found the first route that's not ready to render (waiting on\n          // lazy, or has a loader that hasn't run yet).  Flag that we need to\n          // render a fallback and render up until the appropriate fallback\n          renderFallback = true;\n          if (fallbackIndex >= 0) {\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n          } else {\n            renderedMatches = [renderedMatches[0]];\n          }\n          break;\n        }\n      }\n    }\n  }\n  return renderedMatches.reduceRight(function (outlet, match, index) {\n    // Only data routers handle errors/fallbacks\n    var error;\n    var shouldRenderHydrateFallback = false;\n    var errorElement = null;\n    var hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : undefined;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    var matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    var getChildren = function getChildren() {\n      var children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet: outlet,\n          matches: matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches: matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  var state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n  !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  var route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  var route = useRouteContext(hookName);\n  var thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  var state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  var dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  var state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return {\n      revalidate: dataRouterContext.router.revalidate,\n      state: state.revalidation\n    };\n  }, [dataRouterContext.router.revalidate, state.revalidation]);\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n  var _useDataRouterState = useDataRouterState(DataRouterStateHook.UseMatches),\n    matches = _useDataRouterState.matches,\n    loaderData = _useDataRouterState.loaderData;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return matches.map(function (m) {\n      return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData);\n    });\n  }, [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  var state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  var routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  var state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  var state = useDataRouterState(DataRouterStateHook.UseActionData);\n  var routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : undefined;\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  var error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n  var state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  var routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error !== undefined) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */\nfunction useAsyncValue() {\n  var value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */\nfunction useAsyncError() {\n  var value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nvar blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  var _useDataRouterContext = useDataRouterContext(DataRouterHook.UseBlocker),\n    router = _useDataRouterContext.router,\n    basename = _useDataRouterContext.basename;\n  var state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\"),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    blockerKey = _React$useState2[0],\n    setBlockerKey = _React$useState2[1];\n  var blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (arg) {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we've got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    var currentLocation = arg.currentLocation,\n      nextLocation = arg.nextLocation,\n      historyAction = arg.historyAction;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction: historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var key = String(++blockerId);\n    setBlockerKey(key);\n    return function () {\n      return router.deleteBlocker(key);\n    };\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  var _useDataRouterContext2 = useDataRouterContext(DataRouterHook.UseNavigateStable),\n    router = _useDataRouterContext2.router;\n  var id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  var activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    activeRef.current = true;\n  });\n  var navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nvar START_TRANSITION = \"startTransition\";\nvar startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  var fallbackElement = _ref.fallbackElement,\n    router = _ref.router,\n    future = _ref.future;\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    state = _React$useState4[0],\n    setStateImpl = _React$useState4[1];\n  var _ref11 = future || {},\n    v7_startTransition = _ref11.v7_startTransition;\n  var setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (newState) {\n    if (v7_startTransition && startTransitionImpl) {\n      startTransitionImpl(function () {\n        return setStateImpl(newState);\n      });\n    } else {\n      setStateImpl(newState);\n    }\n  }, [setStateImpl, v7_startTransition]);\n\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    return router.subscribe(setState);\n  }, [router, setState]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: function go(n) {\n        return router.navigate(n);\n      },\n      push: function push(to, state, opts) {\n        return router.navigate(to, {\n          state: state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        });\n      },\n      replace: function replace(to, state, opts) {\n        return router.navigate(to, {\n          replace: true,\n          state: state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        });\n      }\n    };\n  }, [router]);\n  var basename = router.basename || \"/\";\n  var dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return {\n      router: router,\n      navigator: navigator,\n      \"static\": false,\n      basename: basename\n    };\n  }, [router, navigator, basename]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  var routes = _ref2.routes,\n    future = _ref2.future,\n    state = _ref2.state;\n  return useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  var basename = _ref3.basename,\n    children = _ref3.children,\n    initialEntries = _ref3.initialEntries,\n    initialIndex = _ref3.initialIndex,\n    future = _ref3.future;\n  var historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n      initialEntries: initialEntries,\n      initialIndex: initialIndex,\n      v5Compat: true\n    });\n  }\n  var history = historyRef.current;\n  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n      action: history.action,\n      location: history.location\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    state = _React$useState6[0],\n    setStateImpl = _React$useState6[1];\n  var _ref12 = future || {},\n    v7_startTransition = _ref12.v7_startTransition;\n  var setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (newState) {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(function () {\n      return setStateImpl(newState);\n    }) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n  var to = _ref4.to,\n    replace = _ref4.replace,\n    state = _ref4.state,\n    relative = _ref4.relative;\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n  var _React$useContext10 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext),\n    future = _React$useContext10.future,\n    isStatic = _React$useContext10[\"static\"];\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n  var _React$useContext11 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext),\n    matches = _React$useContext11.matches;\n  var _useLocation4 = useLocation(),\n    locationPathname = _useLocation4.pathname;\n  var navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  var path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n  var jsonPath = JSON.stringify(path);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    return navigate(JSON.parse(jsonPath), {\n      replace: replace,\n      state: state,\n      relative: relative\n    });\n  }, [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n  var _ref5$basename = _ref5.basename,\n    basenameProp = _ref5$basename === void 0 ? \"/\" : _ref5$basename,\n    _ref5$children = _ref5.children,\n    children = _ref5$children === void 0 ? null : _ref5$children,\n    locationProp = _ref5.location,\n    _ref5$navigationType = _ref5.navigationType,\n    navigationType = _ref5$navigationType === void 0 ? _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop : _ref5$navigationType,\n    navigator = _ref5.navigator,\n    _ref5$static = _ref5[\"static\"],\n    staticProp = _ref5$static === void 0 ? false : _ref5$static,\n    future = _ref5.future;\n  !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  var basename = basenameProp.replace(/^\\/*/, \"/\");\n  var navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return {\n      basename: basename,\n      navigator: navigator,\n      \"static\": staticProp,\n      future: _extends({\n        v7_relativeSplatPath: false\n      }, future)\n    };\n  }, [basename, future, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n  }\n  var _locationProp = locationProp,\n    _locationProp$pathnam = _locationProp.pathname,\n    pathname = _locationProp$pathnam === void 0 ? \"/\" : _locationProp$pathnam,\n    _locationProp$search = _locationProp.search,\n    search = _locationProp$search === void 0 ? \"\" : _locationProp$search,\n    _locationProp$hash = _locationProp.hash,\n    hash = _locationProp$hash === void 0 ? \"\" : _locationProp$hash,\n    _locationProp$state = _locationProp.state,\n    state = _locationProp$state === void 0 ? null : _locationProp$state,\n    _locationProp$key = _locationProp.key,\n    key = _locationProp$key === void 0 ? \"default\" : _locationProp$key;\n  var locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    var trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search: search,\n        hash: hash,\n        state: state,\n        key: key\n      },\n      navigationType: navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n  var children = _ref6.children,\n    location = _ref6.location;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  var children = _ref7.children,\n    errorElement = _ref7.errorElement,\n    resolve = _ref7.resolve;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nvar neverSettledPromise = new Promise(function () {});\nvar AwaitErrorBoundary = /*#__PURE__*/function (_React$Component2) {\n  function AwaitErrorBoundary(props) {\n    var _this3;\n    _classCallCheck(this, AwaitErrorBoundary);\n    _this3 = _callSuper(this, AwaitErrorBoundary, [props]);\n    _this3.state = {\n      error: null\n    };\n    return _this3;\n  }\n  _inherits(AwaitErrorBoundary, _React$Component2);\n  return _createClass(AwaitErrorBoundary, [{\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(error, errorInfo) {\n      console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        children = _this$props.children,\n        errorElement = _this$props.errorElement,\n        resolve = _this$props.resolve;\n      var promise = null;\n      var status = AwaitRenderStatus.pending;\n      if (!(resolve instanceof Promise)) {\n        // Didn't get a promise - provide as a resolved promise\n        status = AwaitRenderStatus.success;\n        promise = Promise.resolve();\n        Object.defineProperty(promise, \"_tracked\", {\n          get: function get() {\n            return true;\n          }\n        });\n        Object.defineProperty(promise, \"_data\", {\n          get: function get() {\n            return resolve;\n          }\n        });\n      } else if (this.state.error) {\n        // Caught a render error, provide it as a rejected promise\n        status = AwaitRenderStatus.error;\n        var renderError = this.state.error;\n        promise = Promise.reject()[\"catch\"](function () {}); // Avoid unhandled rejection warnings\n        Object.defineProperty(promise, \"_tracked\", {\n          get: function get() {\n            return true;\n          }\n        });\n        Object.defineProperty(promise, \"_error\", {\n          get: function get() {\n            return renderError;\n          }\n        });\n      } else if (resolve._tracked) {\n        // Already tracked promise - check contents\n        promise = resolve;\n        status = \"_error\" in promise ? AwaitRenderStatus.error : \"_data\" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n      } else {\n        // Raw (untracked) promise - track it\n        status = AwaitRenderStatus.pending;\n        Object.defineProperty(resolve, \"_tracked\", {\n          get: function get() {\n            return true;\n          }\n        });\n        promise = resolve.then(function (data) {\n          return Object.defineProperty(resolve, \"_data\", {\n            get: function get() {\n              return data;\n            }\n          });\n        }, function (error) {\n          return Object.defineProperty(resolve, \"_error\", {\n            get: function get() {\n              return error;\n            }\n          });\n        });\n      }\n      if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n        // Freeze the UI by throwing a never resolved promise\n        throw neverSettledPromise;\n      }\n      if (status === AwaitRenderStatus.error && !errorElement) {\n        // No errorElement, throw to the nearest route-level error boundary\n        throw promise._error;\n      }\n      if (status === AwaitRenderStatus.error) {\n        // Render via our errorElement\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: errorElement\n        });\n      }\n      if (status === AwaitRenderStatus.success) {\n        // Render children with resolved value\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: children\n        });\n      }\n\n      // Throw to the suspense boundary\n      throw promise;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n  }]);\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */\nfunction ResolveAwait(_ref8) {\n  var children = _ref8.children;\n  var data = useAsyncValue();\n  var toRender = typeof children === \"function\" ? children(data) : children;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  var routes = [];\n  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, function (element, index) {\n    if (! /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    var treePath = [].concat(_toConsumableArray(parentPath), [index]);\n    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n    !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n    var route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n  var updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (true) {\n      if (route.element) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n      }\n    }\n    Object.assign(updates, {\n      element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.HydrateFallback) {\n    if (true) {\n      if (route.hydrateFallbackElement) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : 0;\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\n      HydrateFallback: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (true) {\n      if (route.errorElement) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes: routes,\n    mapRouteProperties: mapRouteProperties,\n    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,\n    unstable_patchRoutesOnMiss: opts == null ? void 0 : opts.unstable_patchRoutesOnMiss\n  }).initialize();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQjtBQUNrUjtBQUNyRjtBQUU1TixTQUFTeUIsUUFBUUEsQ0FBQSxFQUFHO0VBQ2xCQSxRQUFRLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHRCxNQUFNLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLENBQUMsR0FBRyxVQUFVQyxNQUFNLEVBQUU7SUFDbEUsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFRixDQUFDLEVBQUUsRUFBRTtNQUN6QyxJQUFJRyxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBQyxDQUFDO01BQ3pCLEtBQUssSUFBSUksR0FBRyxJQUFJRCxNQUFNLEVBQUU7UUFDdEIsSUFBSVAsTUFBTSxDQUFDUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixNQUFNLEVBQUVDLEdBQUcsQ0FBQyxFQUFFO1VBQ3JETCxNQUFNLENBQUNLLEdBQUcsQ0FBQyxHQUFHRCxNQUFNLENBQUNDLEdBQUcsQ0FBQztRQUMzQjtNQUNGO0lBQ0Y7SUFDQSxPQUFPTCxNQUFNO0VBQ2YsQ0FBQztFQUNELE9BQU9KLFFBQVEsQ0FBQ2EsS0FBSyxDQUFDLElBQUksRUFBRVAsU0FBUyxDQUFDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxJQUFNUSxpQkFBaUIsR0FBRyxhQUFhdkMsZ0RBQW1CLENBQUMsSUFBSSxDQUFDO0FBQ2hFLElBQUksTUFBdUM7RUFDekN1QyxpQkFBaUIsQ0FBQ0UsV0FBVyxHQUFHLFlBQVk7QUFDOUM7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LEtBQUssQ0FBQyxHQUFHQSxJQUFJLENBQUN1RjtFQUMzRCxDQUFDLENBQUMsQ0FBQ0MsVUFBVSxDQUFDLENBQUM7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXRlLXJlYWN0LXR5cGVzY3JpcHQtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9pbmRleC5qcz8yYTFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIHY2LjI0LjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVU5TQUZFX2ludmFyaWFudCwgam9pblBhdGhzLCBtYXRjaFBhdGgsIFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzLCBVTlNBRkVfd2FybmluZywgcmVzb2x2ZVRvLCBwYXJzZVBhdGgsIG1hdGNoUm91dGVzLCBBY3Rpb24sIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgc3RyaXBCYXNlbmFtZSwgSURMRV9CTE9DS0VSLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgQWJvcnRlZERlZmVycmVkRXJyb3IsIGNyZWF0ZVJvdXRlciB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsIGNyZWF0ZVBhdGgsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXNvbHZlUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vIENyZWF0ZSByZWFjdC1zcGVjaWZpYyB0eXBlcyBmcm9tIHRoZSBhZ25vc3RpYyB0eXBlcyBpbiBAcmVtaXgtcnVuL3JvdXRlciB0b1xuLy8gZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyXG5jb25zdCBEYXRhUm91dGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xufVxuY29uc3QgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbn1cbmNvbnN0IEF3YWl0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBBd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG59XG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIGA8Um91dGVyPmAgQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuXG5jb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbn1cbmNvbnN0IFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlXG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xufVxuY29uc3QgUm91dGVFcnJvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICovXG5mdW5jdGlvbiB1c2VIcmVmKHRvLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIGhhc2gsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoXG4gIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHtcbiAgICBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsXG4gICAgc2VhcmNoLFxuICAgIGhhc2hcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIGA8Um91dGVyPmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAqL1xuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBQYXRoTWF0Y2ggb2JqZWN0IGlmIHRoZSBnaXZlbiBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogYDxOYXZMaW5rPmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbWF0Y2hcbiAqL1xuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBwYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSwgW3BhdGhuYW1lLCBwYXR0ZXJuXSk7XG59XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgdGhlIG5hdmlnYXRlKCkgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSB1c2VOYXZpZ2F0ZSgpLlxuICovXG5cbmNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IFwiWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gXCIgKyBcInlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLlwiO1xuXG4vLyBNdXRlIHdhcm5pbmdzIGZvciBjYWxscyB0byB1c2VOYXZpZ2F0ZSBpbiBTU1IgZW52aXJvbm1lbnRzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XG4gIGxldCBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYztcbiAgaWYgKCFpc1N0YXRpYykge1xuICAgIC8vIFdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgdGhpcyBvbmNlIHJlYWN0IDE4LjMgaXMgcmVsZWFzZWRcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGNiKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSBgPExpbms+YHMsIGJ1dFxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQge1xuICAgIGlzRGF0YVJvdXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIC8vIENvbmRpdGlvbmFsIHVzYWdlIGlzIE9LIGhlcmUgYmVjYXVzZSB0aGUgdXNhZ2Ugb2YgYSBkYXRhIHJvdXRlciBpcyBzdGF0aWNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHJldHVybiBpc0RhdGFSb3V0ZSA/IHVzZU5hdmlnYXRlU3RhYmxlKCkgOiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgZnV0dXJlLFxuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDogdm9pZCAwO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIGhpc3RvcnkgbGlzdGVuZXIgeWV0XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvLCBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksIGxvY2F0aW9uUGF0aG5hbWUsIG9wdGlvbnMucmVsYXRpdmUgPT09IFwicGF0aFwiKTtcblxuICAgIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgICAvLyB0byBoYW5kaW5nIG9mZiB0byBoaXN0b3J5IChidXQgb25seSBpZiB3ZSdyZSBub3QgaW4gYSBkYXRhIHJvdXRlcixcbiAgICAvLyBvdGhlcndpc2UgaXQnbGwgcHJlcGVuZCB0aGUgYmFzZW5hbWUgaW5zaWRlIG9mIHRoZSByb3V0ZXIpLlxuICAgIC8vIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4gd2UgbmF2aWdhdGUgdG8gdGhlIHJhdyBiYXNlbmFtZVxuICAgIC8vIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYVxuICAgIC8vIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgIH1cbiAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShwYXRoLCBvcHRpb25zLnN0YXRlLCBvcHRpb25zKTtcbiAgfSwgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgZGF0YVJvdXRlckNvbnRleHRdKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuY29uc3QgT3V0bGV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgKGlmIHByb3ZpZGVkKSBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXQtY29udGV4dFxuICovXG5mdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IGA8T3V0bGV0PmAgdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXRcbiAqL1xuZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQpIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBvdXRsZXQpO1xuICB9XG4gIHJldHVybiBvdXRsZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcmVzb2x2ZWQtcGF0aFxuICovXG5mdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG8sIF90ZW1wMikge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBsZXQge1xuICAgIGZ1dHVyZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpLCBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXG4gKiBlbGVtZW50cyBpbiB0aGUgdHJlZSBtdXN0IHJlbmRlciBhbiBgPE91dGxldD5gIHRvIHJlbmRlciB0aGVpciBjaGlsZCByb3V0ZSdzXG4gKiBlbGVtZW50LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJvdXRlc1xuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnKTtcbn1cblxuLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gd2l0aCBhY2NlcHQgb3B0aW9uYWwgcGFyYW0gZm9yIFJvdXRlclByb3ZpZGVyIHVzYWdlXG5mdW5jdGlvbiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgbGV0IHBhcmVudFBhdGhuYW1lID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWUgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xuICB9XG4gIGxldCBsb2NhdGlvbkZyb21Db250ZXh0ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICB2YXIgX3BhcnNlZExvY2F0aW9uQXJnJHBhO1xuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICAhKHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgKChfcGFyc2VkTG9jYXRpb25BcmckcGEgPSBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJzZWRMb2NhdGlvbkFyZyRwYS5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBgPFJvdXRlcyBsb2NhdGlvbj5gIG9yIGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilgLCBcIiArIFwidGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIFwiICsgKFwibWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcXFwiXCIgKyBwYXJlbnRQYXRobmFtZUJhc2UgKyBcIlxcXCIgXCIpICsgKFwiYnV0IHBhdGhuYW1lIFxcXCJcIiArIHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lICsgXCJcXFwiIHdhcyBnaXZlbiBpbiB0aGUgYGxvY2F0aW9uYCBwcm9wLlwiKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChwYXJlbnRQYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgYnkgcmVtb3ZpbmcgdGhlICMgb2YgVVJMIHNlZ21lbnRzIHRoZVxuICAgIC8vIHBhcmVudFBhdGhuYW1lQmFzZSBoYXMsIGluc3RlYWQgb2YgcmVtb3ZpbmcgYmFzZWQgb24gY2hhcmFjdGVyIGNvdW50LlxuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBjYW4ndCBndWFyYW50ZWUgdGhhdCBpbmNvbWluZy9vdXRnb2luZyBlbmNvZGluZ3MvXG4gICAgLy8gZGVjb2RpbmdzIHdpbGwgbWF0Y2ggZXhhY3RseS5cbiAgICAvLyBXZSBkZWNvZGUgcGF0aHMgYmVmb3JlIG1hdGNoaW5nIG9uIGEgcGVyLXNlZ21lbnQgYmFzaXMgd2l0aFxuICAgIC8vIGRlY29kZVVSSUNvbXBvbmVudCgpLCBidXQgd2UgcmUtZW5jb2RlIHBhdGhuYW1lcyB2aWEgYG5ldyBVUkwoKWAgc28gdGhleVxuICAgIC8vIG1hdGNoIHdoYXQgYHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZWAgd291bGQgcmVmbGVjdC4gIFRob3NlIGRvbid0IDEwMCVcbiAgICAvLyBhbGlnbiB3aGVuIGl0IGNvbWVzIHRvIGVuY29kZWQgVVJJIGNoYXJhY3RlcnMgc3VjaCBhcyAlIGFuZCAmLlxuICAgIC8vXG4gICAgLy8gU28gd2UgbWF5IGVuZCB1cCB3aXRoOlxuICAgIC8vICAgcGF0aG5hbWU6ICAgICAgICAgICBcIi9kZXNjZW5kYW50L2ElMjViL21hdGNoXCJcbiAgICAvLyAgIHBhcmVudFBhdGhuYW1lQmFzZTogXCIvZGVzY2VuZGFudC9hJWJcIlxuICAgIC8vXG4gICAgLy8gQW5kIHRoZSBkaXJlY3Qgc3Vic3RyaW5nIHJlbW92YWwgYXBwcm9hY2ggd29uJ3Qgd29yayA6L1xuICAgIGxldCBwYXJlbnRTZWdtZW50cyA9IHBhcmVudFBhdGhuYW1lQmFzZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBzZWdtZW50cyA9IHBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBcIi9cIiArIHNlZ21lbnRzLnNsaWNlKHBhcmVudFNlZ21lbnRzLmxlbmd0aCkuam9pbihcIi9cIik7XG4gIH1cbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHtcbiAgICBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWVcbiAgfSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsIFwiTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmxhenkgIT09IHVuZGVmaW5lZCwgXCJNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiICsgXCJkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIFwiICsgXCJudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFxcXCJlbXB0eVxcXCIgcGFnZS5cIikgOiB2b2lkIDA7XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMgJiYgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICBwYXRobmFtZTogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWUpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVdKSxcbiAgICBwYXRobmFtZUJhc2U6IG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXJlbnRQYXRobmFtZUJhc2UgOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgfSkpLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSk7XG5cbiAgLy8gV2hlbiBhIHVzZXIgcGFzc2VzIGluIGEgYGxvY2F0aW9uQXJnYCwgdGhlIGFzc29jaWF0ZWQgcm91dGVzIG5lZWQgdG9cbiAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxuICAvLyB0byB1c2UgdGhlIHNjb3BlZCBsb2NhdGlvbiBpbnN0ZWFkIG9mIHRoZSBnbG9iYWwgbG9jYXRpb24uXG4gIGlmIChsb2NhdGlvbkFyZyAmJiByZW5kZXJlZE1hdGNoZXMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBsb2NhdGlvbjogX2V4dGVuZHMoe1xuICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgaGFzaDogXCJcIixcbiAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiXG4gICAgICAgIH0sIGxvY2F0aW9uKSxcbiAgICAgICAgbmF2aWdhdGlvblR5cGU6IEFjdGlvbi5Qb3BcbiAgICAgIH1cbiAgICB9LCByZW5kZXJlZE1hdGNoZXMpO1xuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgKyBcIiBcIiArIGVycm9yLnN0YXR1c1RleHQgOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0ge1xuICAgIHBhZGRpbmc6IFwiMC41cmVtXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXlcbiAgfTtcbiAgbGV0IGNvZGVTdHlsZXMgPSB7XG4gICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXlcbiAgfTtcbiAgbGV0IGRldkluZm8gPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsZWQgYnkgUmVhY3QgUm91dGVyIGRlZmF1bHQgRXJyb3JCb3VuZGFyeTpcIiwgZXJyb3IpO1xuICAgIGRldkluZm8gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiXFx1RDgzRFxcdURDQkYgSGV5IGRldmVsb3BlciBcXHVEODNEXFx1REM0QlwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzIGJ5IHByb3ZpZGluZyB5b3VyIG93biBcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtcbiAgICAgIHN0eWxlOiBjb2RlU3R5bGVzXG4gICAgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtcbiAgICAgIHN0eWxlOiBjb2RlU3R5bGVzXG4gICAgfSwgXCJlcnJvckVsZW1lbnRcIiksIFwiIHByb3Agb24geW91ciByb3V0ZS5cIikpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImgzXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfVxuICB9LCBtZXNzYWdlKSwgc3RhY2sgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7XG4gICAgc3R5bGU6IHByZVN0eWxlc1xuICB9LCBzdGFjaykgOiBudWxsLCBkZXZJbmZvKTtcbn1cbmNvbnN0IGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0RXJyb3JDb21wb25lbnQsIG51bGwpO1xuY2xhc3MgUmVuZGVyRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvclxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uLCB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlIGNvbnRpbnVlcyB0byBkaXNwbGF5LlxuICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRoZSBlcnJvciB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgY2hhbmdpbmcgbG9jYXRpb25zLCBwcmVzZXJ2ZSB0aGUgbG9jYXRpb24gYnV0IHN0aWxsIHN1cmZhY2VcbiAgICAvLyBhbnkgbmV3IGVycm9ycyB0aGF0IG1heSBjb21lIHRocm91Z2guIFdlIHJldGFpbiB0aGUgZXhpc3RpbmcgZXJyb3IsIHdlIGRvXG4gICAgLy8gdGhpcyBiZWNhdXNlIHRoZSBlcnJvciBwcm92aWRlZCBmcm9tIHRoZSBhcHAgc3RhdGUgbWF5IGJlIGNsZWFyZWQgd2l0aG91dFxuICAgIC8vIHRoZSBsb2NhdGlvbiBjaGFuZ2luZy5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yICE9PSB1bmRlZmluZWQgPyBwcm9wcy5lcnJvciA6IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlJlYWN0IFJvdXRlciBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsIGVycm9yLCBlcnJvckluZm8pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciAhPT0gdW5kZWZpbmVkID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICB9KSkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByb3V0ZUNvbnRleHQsXG4gICAgbWF0Y2gsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuXG4gIC8vIFRyYWNrIGhvdyBkZWVwIHdlIGdvdCBpbiBvdXIgcmVuZGVyIHBhc3MgdG8gZW11bGF0ZSBTU1IgY29tcG9uZW50RGlkQ2F0Y2hcbiAgLy8gaW4gYSBEYXRhU3RhdGljUm91dGVyXG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcm91dGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMsIHBhcmVudE1hdGNoZXMsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKSB7XG4gIHZhciBfZGF0YVJvdXRlclN0YXRlMjtcbiAgaWYgKHBhcmVudE1hdGNoZXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmVudE1hdGNoZXMgPSBbXTtcbiAgfVxuICBpZiAoZGF0YVJvdXRlclN0YXRlID09PSB2b2lkIDApIHtcbiAgICBkYXRhUm91dGVyU3RhdGUgPSBudWxsO1xuICB9XG4gIGlmIChmdXR1cmUgPT09IHZvaWQgMCkge1xuICAgIGZ1dHVyZSA9IG51bGw7XG4gIH1cbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIHZhciBfZGF0YVJvdXRlclN0YXRlO1xuICAgIGlmICgoX2RhdGFSb3V0ZXJTdGF0ZSA9IGRhdGFSb3V0ZXJTdGF0ZSkgIT0gbnVsbCAmJiBfZGF0YVJvdXRlclN0YXRlLmVycm9ycykge1xuICAgICAgLy8gRG9uJ3QgYmFpbCBpZiB3ZSBoYXZlIGRhdGEgcm91dGVyIGVycm9ycyBzbyB3ZSBjYW4gcmVuZGVyIHRoZW0gaW4gdGhlXG4gICAgICAvLyBib3VuZGFyeS4gIFVzZSB0aGUgcHJlLW1hdGNoZWQgKG9yIHNoaW1tZWQpIG1hdGNoZXNcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuXG4gIC8vIElmIHdlIGhhdmUgZGF0YSBlcnJvcnMsIHRyaW0gbWF0Y2hlcyB0byB0aGUgaGlnaGVzdCBlcnJvciBib3VuZGFyeVxuICBsZXQgZXJyb3JzID0gKF9kYXRhUm91dGVyU3RhdGUyID0gZGF0YVJvdXRlclN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSb3V0ZXJTdGF0ZTIuZXJyb3JzO1xuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgobSA9PiBtLnJvdXRlLmlkICYmIChlcnJvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yc1ttLnJvdXRlLmlkXSkgIT09IHVuZGVmaW5lZCk7XG4gICAgIShlcnJvckluZGV4ID49IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciBlcnJvcnMgb24gcm91dGUgSURzOiBcIiArIE9iamVjdC5rZXlzKGVycm9ycykuam9pbihcIixcIikpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKSk7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBpbiBhIHBhcnRpYWwgaHlkcmF0aW9uIG1vZGUsIGRldGVjdCBpZiB3ZSBuZWVkIHRvIHJlbmRlciBkb3duIHRvXG4gIC8vIGEgZ2l2ZW4gSHlkcmF0ZUZhbGxiYWNrIHdoaWxlIHdlIGxvYWQgdGhlIHJlc3Qgb2YgdGhlIGh5ZHJhdGlvbiBkYXRhXG4gIGxldCByZW5kZXJGYWxsYmFjayA9IGZhbHNlO1xuICBsZXQgZmFsbGJhY2tJbmRleCA9IC0xO1xuICBpZiAoZGF0YVJvdXRlclN0YXRlICYmIGZ1dHVyZSAmJiBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbWF0Y2ggPSByZW5kZXJlZE1hdGNoZXNbaV07XG4gICAgICAvLyBUcmFjayB0aGUgZGVlcGVzdCBmYWxsYmFjayB1cCB1bnRpbCB0aGUgZmlyc3Qgcm91dGUgd2l0aG91dCBkYXRhXG4gICAgICBpZiAobWF0Y2gucm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgZmFsbGJhY2tJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICB9ID0gZGF0YVJvdXRlclN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNUb1J1bkxvYWRlciA9IG1hdGNoLnJvdXRlLmxvYWRlciAmJiBsb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkICYmICghZXJyb3JzIHx8IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG5lZWRzVG9SdW5Mb2FkZXIpIHtcbiAgICAgICAgICAvLyBXZSBmb3VuZCB0aGUgZmlyc3Qgcm91dGUgdGhhdCdzIG5vdCByZWFkeSB0byByZW5kZXIgKHdhaXRpbmcgb25cbiAgICAgICAgICAvLyBsYXp5LCBvciBoYXMgYSBsb2FkZXIgdGhhdCBoYXNuJ3QgcnVuIHlldCkuICBGbGFnIHRoYXQgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIHJlbmRlciBhIGZhbGxiYWNrIGFuZCByZW5kZXIgdXAgdW50aWwgdGhlIGFwcHJvcHJpYXRlIGZhbGxiYWNrXG4gICAgICAgICAgcmVuZGVyRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGlmIChmYWxsYmFja0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBmYWxsYmFja0luZGV4ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IFtyZW5kZXJlZE1hdGNoZXNbMF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIC8vIE9ubHkgZGF0YSByb3V0ZXJzIGhhbmRsZSBlcnJvcnMvZmFsbGJhY2tzXG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgZXJyb3IgPSBlcnJvcnMgJiYgbWF0Y2gucm91dGUuaWQgPyBlcnJvcnNbbWF0Y2gucm91dGUuaWRdIDogdW5kZWZpbmVkO1xuICAgICAgZXJyb3JFbGVtZW50ID0gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGRlZmF1bHRFcnJvckVsZW1lbnQ7XG4gICAgICBpZiAocmVuZGVyRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPCAwICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgd2FybmluZ09uY2UoXCJyb3V0ZS1mYWxsYmFja1wiLCBmYWxzZSwgXCJObyBgSHlkcmF0ZUZhbGxiYWNrYCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlbmRlciBkdXJpbmcgaW5pdGlhbCBoeWRyYXRpb25cIik7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFja0luZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBsZXQgY2hpbGRyZW47XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBlcnJvckVsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjaykge1xuICAgICAgICBjaGlsZHJlbiA9IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLkNvbXBvbmVudCkge1xuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZGUtb3B0aW1pemVkIHBhdGggc2luY2UgUmVhY3Qgd29uJ3QgcmUtdXNlIHRoZVxuICAgICAgICAvLyBSZWFjdEVsZW1lbnQgc2luY2UgaXQncyBpZGVudGl0eSBjaGFuZ2VzIHdpdGggZWFjaCBuZXdcbiAgICAgICAgLy8gUmVhY3QuY3JlYXRlRWxlbWVudCBjYWxsLiAgV2Uga2VlcCB0aGlzIHNvIGZvbGtzIGNhbiB1c2VcbiAgICAgICAgLy8gYDxSb3V0ZSBDb21wb25lbnQ9ey4uLn0+YCBpbiBgPFJvdXRlcz5gIGJ1dCBnZW5lcmFsbHkgYENvbXBvbmVudGBcbiAgICAgICAgLy8gdXNhZ2UgaXMgb25seSBhZHZpc2VkIGluIGBSb3V0ZXJQcm92aWRlcmAgd2hlbiB3ZSBjYW4gY29udmVydCBpdCB0b1xuICAgICAgICAvLyBgZWxlbWVudGAgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gbWF0Y2gucm91dGUuZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gb3V0bGV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbmRlcmVkUm91dGUsIHtcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIE9ubHkgd3JhcCBpbiBhbiBlcnJvciBib3VuZGFyeSB3aXRoaW4gZGF0YSByb3V0ZXIgdXNhZ2VzIHdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IG9uIHRoaXMgcm91dGUuICBPdGhlcndpc2UgbGV0IGl0IGJ1YmJsZSB1cCB0b1xuICAgIC8vIGFuIGFuY2VzdG9yIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyRXJyb3JCb3VuZGFyeSwge1xuICAgICAgbG9jYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogZGF0YVJvdXRlclN0YXRlLnJldmFsaWRhdGlvbixcbiAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgY2hpbGRyZW46IGdldENoaWxkcmVuKCksXG4gICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgb3V0bGV0OiBudWxsLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBpc0RhdGFSb3V0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pIDogZ2V0Q2hpbGRyZW4oKTtcbiAgfSwgbnVsbCk7XG59XG52YXIgRGF0YVJvdXRlckhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZVJldmFsaWRhdG9yXCJdID0gXCJ1c2VSZXZhbGlkYXRvclwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZU5hdmlnYXRlU3RhYmxlXCJdID0gXCJ1c2VOYXZpZ2F0ZVwiO1xuICByZXR1cm4gRGF0YVJvdXRlckhvb2s7XG59KERhdGFSb3V0ZXJIb29rIHx8IHt9KTtcbnZhciBEYXRhUm91dGVyU3RhdGVIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VMb2FkZXJEYXRhXCJdID0gXCJ1c2VMb2FkZXJEYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VBY3Rpb25EYXRhXCJdID0gXCJ1c2VBY3Rpb25EYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUVycm9yXCJdID0gXCJ1c2VSb3V0ZUVycm9yXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VOYXZpZ2F0aW9uXCJdID0gXCJ1c2VOYXZpZ2F0aW9uXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUxvYWRlckRhdGFcIl0gPSBcInVzZVJvdXRlTG9hZGVyRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTWF0Y2hlc1wiXSA9IFwidXNlTWF0Y2hlc1wiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlSWRcIl0gPSBcInVzZVJvdXRlSWRcIjtcbiAgcmV0dXJuIERhdGFSb3V0ZXJTdGF0ZUhvb2s7XG59KERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwge30pO1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gaG9va05hbWUgKyBcIiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLlwiO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICAhY3R4ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gcm91dGU7XG59XG5cbi8vIEludGVybmFsIHZlcnNpb24gd2l0aCBob29rTmFtZS1hd2FyZSBkZWJ1Z2dpbmdcbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICF0aGlzUm91dGUucm91dGUuaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBob29rTmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgSUQgZm9yIHRoZSBuZWFyZXN0IGNvbnRleHR1YWwgcm91dGVcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVJZCgpIHtcbiAgcmV0dXJuIHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVJZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uLCBkZWZhdWx0aW5nIHRvIGFuIFwiaWRsZVwiIG5hdmlnYXRpb24gd2hlblxuICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcbiAgcmV0dXJuIHN0YXRlLm5hdmlnYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJldmFsaWRhdGUgZnVuY3Rpb24gZm9yIG1hbnVhbGx5IHRyaWdnZXJpbmcgcmV2YWxpZGF0aW9uLCBhcyB3ZWxsXG4gKiBhcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbnkgbWFudWFsIHJldmFsaWRhdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxuICAgIHN0YXRlOiBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgfSksIFtkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSwgc3RhdGUucmV2YWxpZGF0aW9uXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aXZlIHJvdXRlIG1hdGNoZXMsIHVzZWZ1bCBmb3IgYWNjZXNzaW5nIGxvYWRlckRhdGEgZm9yXG4gKiBwYXJlbnQvY2hpbGQgcm91dGVzIG9yIHRoZSByb3V0ZSBcImhhbmRsZVwiIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VNYXRjaGVzKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hlcy5tYXAobSA9PiBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgbG9hZGVyRGF0YSkpLCBbbWF0Y2hlcywgbG9hZGVyRGF0YV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlciBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBsb2FkZXJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgaWYgKHN0YXRlLmVycm9ycyAmJiBzdGF0ZS5lcnJvcnNbcm91dGVJZF0gIT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvckVsZW1lbnQgKHJvdXRlSWQ6IFwiICsgcm91dGVJZCArIFwiKVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlckRhdGEgZm9yIHRoZSBnaXZlbiByb3V0ZUlkXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGlvbiBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQWN0aW9uRGF0YSk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgcmV0dXJuIHN0YXRlLmFjdGlvbkRhdGEgPyBzdGF0ZS5hY3Rpb25EYXRhW3JvdXRlSWRdIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgZXJyb3IsIHdoaWNoIGNvdWxkIGJlIGEgbG9hZGVyL2FjdGlvblxuICogZXJyb3Igb3IgYSByZW5kZXIgZXJyb3IuICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXJcbiAqIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IHRvIGRpc3BsYXkgYSBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVFcnJvcigpIHtcbiAgdmFyIF9zdGF0ZSRlcnJvcnM7XG4gIGxldCBlcnJvciA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVFcnJvckNvbnRleHQpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xuXG4gIC8vIElmIHRoaXMgd2FzIGEgcmVuZGVyIGVycm9yLCB3ZSBwdXQgaXQgaW4gYSBSb3V0ZUVycm9yIGNvbnRleHQgaW5zaWRlXG4gIC8vIG9mIFJlbmRlckVycm9yQm91bmRhcnlcbiAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBPdGhlcndpc2UgbG9vayBmb3IgZXJyb3JzIGZyb20gb3VyIGRhdGEgcm91dGVyIHN0YXRlXG4gIHJldHVybiAoX3N0YXRlJGVycm9ycyA9IHN0YXRlLmVycm9ycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRlcnJvcnNbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaGFwcHktcGF0aCBkYXRhIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgYDxBd2FpdCAvPmAgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdXNlQXN5bmNWYWx1ZSgpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVycm9yIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgYDxBd2FpdCAvPmAgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9lcnJvcjtcbn1cbmxldCBibG9ja2VySWQgPSAwO1xuXG4vKipcbiAqIEFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byBibG9jayBuYXZpZ2F0aW9ucyB3aXRoaW4gdGhlIFNQQSBhbmQgcHJlc2VudCB0aGVcbiAqIHVzZXIgYSBjb25maXJtYXRpb24gZGlhbG9nIHRvIGNvbmZpcm0gdGhlIG5hdmlnYXRpb24uICBNb3N0bHkgdXNlZCB0byBhdm9pZFxuICogdXNpbmcgaGFsZi1maWxsZWQgZm9ybSBkYXRhLiAgVGhpcyBkb2VzIG5vdCBoYW5kbGUgaGFyZC1yZWxvYWRzIG9yXG4gKiBjcm9zcy1vcmlnaW4gbmF2aWdhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgbGV0IHtcbiAgICByb3V0ZXIsXG4gICAgYmFzZW5hbWVcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUJsb2NrZXIpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VCbG9ja2VyKTtcbiAgbGV0IFtibG9ja2VyS2V5LCBzZXRCbG9ja2VyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpO1xuICBsZXQgYmxvY2tlckZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soYXJnID0+IHtcbiAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiAhIXNob3VsZEJsb2NrO1xuICAgIH1cbiAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gc2hvdWxkQmxvY2soYXJnKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGV5IHByb3ZpZGVkIHVzIGEgZnVuY3Rpb24gYW5kIHdlJ3ZlIGdvdCBhbiBhY3RpdmUgYmFzZW5hbWUsIHN0cmlwXG4gICAgLy8gaXQgZnJvbSB0aGUgbG9jYXRpb25zIHdlIGV4cG9zZSB0byB0aGUgdXNlciB0byBtYXRjaCB0aGUgYmVoYXZpb3Igb2ZcbiAgICAvLyB1c2VMb2NhdGlvblxuICAgIGxldCB7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSA9IGFyZztcbiAgICByZXR1cm4gc2hvdWxkQmxvY2soe1xuICAgICAgY3VycmVudExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSksXG4gICAgICBuZXh0TG9jYXRpb246IF9leHRlbmRzKHt9LCBuZXh0TG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbmV4dExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KSxcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgfSwgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja10pO1xuXG4gIC8vIFRoaXMgZWZmZWN0IGlzIGluIGNoYXJnZSBvZiBibG9ja2VyIGtleSBhc3NpZ25tZW50IGFuZCBkZWxldGlvbiAod2hpY2ggaXNcbiAgLy8gdGlnaHRseSBjb3VwbGVkIHRvIHRoZSBrZXkpXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGtleSA9IFN0cmluZygrK2Jsb2NrZXJJZCk7XG4gICAgc2V0QmxvY2tlcktleShrZXkpO1xuICAgIHJldHVybiAoKSA9PiByb3V0ZXIuZGVsZXRlQmxvY2tlcihrZXkpO1xuICB9LCBbcm91dGVyXSk7XG5cbiAgLy8gVGhpcyBlZmZlY3QgaGFuZGxlcyBhc3NpZ25pbmcgdGhlIGJsb2NrZXJGdW5jdGlvbi4gIFRoaXMgaXMgdG8gaGFuZGxlXG4gIC8vIHVuc3RhYmxlIGJsb2NrZXIgZnVuY3Rpb24gaWRlbnRpdGllcywgYW5kIGhhcHBlbnMgb25seSBhZnRlciB0aGUgcHJpb3JcbiAgLy8gZWZmZWN0IHNvIHdlIGRvbid0IGdldCBhbiBvcnBoYW5lZCBibG9ja2VyRnVuY3Rpb24gaW4gdGhlIHJvdXRlciB3aXRoIGFcbiAgLy8ga2V5IG9mIFwiXCIuICBVbnRpbCB0aGVuIHdlIGp1c3QgaGF2ZSB0aGUgSURMRV9CTE9DS0VSLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyS2V5ICE9PSBcIlwiKSB7XG4gICAgICByb3V0ZXIuZ2V0QmxvY2tlcihibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb24pO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSk7XG5cbiAgLy8gUHJlZmVyIHRoZSBibG9ja2VyIGZyb20gYHN0YXRlYCBub3QgYHJvdXRlci5zdGF0ZWAgc2luY2UgRGF0YVJvdXRlckNvbnRleHRcbiAgLy8gaXMgbWVtb2l6ZWQgc28gdGhpcyBlbnN1cmVzIHdlIHVwZGF0ZSBvbiBibG9ja2VyIHN0YXRlIHVwZGF0ZXNcbiAgcmV0dXJuIGJsb2NrZXJLZXkgJiYgc3RhdGUuYmxvY2tlcnMuaGFzKGJsb2NrZXJLZXkpID8gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpIDogSURMRV9CTE9DS0VSO1xufVxuXG4vKipcbiAqIFN0YWJsZSB2ZXJzaW9uIG9mIHVzZU5hdmlnYXRlIHRoYXQgaXMgdXNlZCB3aGVuIHdlIGFyZSBpbiB0aGUgY29udGV4dCBvZlxuICogYSBSb3V0ZXJQcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGVTdGFibGUoKSB7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VOYXZpZ2F0ZVN0YWJsZSk7XG4gIGxldCBpZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA6IHZvaWQgMDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaGVyZSBzaW5jZSBpZiB0aGlzIGhhcHBlbnMgb24gZmlyc3QgcmVuZGVyIHRoZSBuYXZpZ2F0ZVxuICAgIC8vIGlzIHVzZWxlc3MgYmVjYXVzZSB3ZSBoYXZlbid0IHdpcmVkIHVwIG91ciByb3V0ZXIgc3Vic2NyaWJlciB5ZXRcbiAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCBfZXh0ZW5kcyh7XG4gICAgICAgIGZyb21Sb3V0ZUlkOiBpZFxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgaWRdKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuY29uc3QgYWxyZWFkeVdhcm5lZCA9IHt9O1xuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5LCBjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICogaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBIb3dldmVyLCB0aGF0IGludHJvZHVjZXMgd2VicGFjay90ZXJzZXIgbWluaWZpY2F0aW9uIGlzc3VlcyBpbiBwcm9kdWN0aW9uIGJ1aWxkc1xuICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gIHRoaXMgZXhwb3J0ZWQgcmVmZXJlbmNlIG9uY2UgdXAgZnJvbnQgcmVzb2x2ZXMgdGhhdCBpc3N1ZS5cblxuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4qL1xuY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG5jb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl07XG5cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoX3JlZikge1xuICBsZXQge1xuICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICByb3V0ZXIsXG4gICAgZnV0dXJlXG4gIH0gPSBfcmVmO1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIGlmICh2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCkge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgICB9XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuXG4gIC8vIE5lZWQgdG8gdXNlIGEgbGF5b3V0IGVmZmVjdCBoZXJlIHNvIHdlIGFyZSBzdWJzY3JpYmVkIGVhcmx5IGVub3VnaCB0b1xuICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxsYmFja0VsZW1lbnQgPT0gbnVsbCB8fCAhcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uLCBcImA8Um91dGVyUHJvdmlkZXIgZmFsbGJhY2tFbGVtZW50PmAgaXMgZGVwcmVjYXRlZCB3aGVuIHVzaW5nIFwiICsgXCJgdjdfcGFydGlhbEh5ZHJhdGlvbmAsIHVzZSBhIGBIeWRyYXRlRmFsbGJhY2tgIGNvbXBvbmVudCBpbnN0ZWFkXCIpIDogdm9pZCAwO1xuICAgIC8vIE9ubHkgbG9nIHRoaXMgb25jZSBvbiBpbml0aWFsIG1vdW50XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIGxldCBuYXZpZ2F0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IG4gPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KSxcbiAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBmYWxzZSxcbiAgICBiYXNlbmFtZVxuICB9KSwgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV0pO1xuXG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdGF0ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yLFxuICAgIGZ1dHVyZToge1xuICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IHJvdXRlci5mdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGhcbiAgICB9XG4gIH0sIHN0YXRlLmluaXRpYWxpemVkIHx8IHJvdXRlci5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXMsIHtcbiAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgZnV0dXJlOiByb3V0ZXIuZnV0dXJlLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KSA6IGZhbGxiYWNrRWxlbWVudCkpKSwgbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgcm91dGVzLFxuICAgIGZ1dHVyZSxcbiAgICBzdGF0ZVxuICB9ID0gX3JlZjI7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdW5kZWZpbmVkLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgc3RvcmVzIGFsbCBlbnRyaWVzIGluIG1lbW9yeS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL21lbW9yeS1yb3V0ZXJcbiAqL1xuZnVuY3Rpb24gTWVtb3J5Um91dGVyKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjM7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXgsXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeSxcbiAgICBmdXR1cmU6IGZ1dHVyZVxuICB9KTtcbn1cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxuICogYWJsZSB0byB1c2UgaG9va3MuIEluIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgdGhlXG4gKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvbmF2aWdhdGVcbiAqL1xuZnVuY3Rpb24gTmF2aWdhdGUoX3JlZjQpIHtcbiAgbGV0IHtcbiAgICB0byxcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHJlbGF0aXZlXG4gIH0gPSBfcmVmNDtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCI8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgZnV0dXJlLFxuICAgIHN0YXRpYzogaXNTdGF0aWNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyghaXNTdGF0aWMsIFwiPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBcIiArIFwiVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIFwiICsgXCJvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5cIikgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuXG4gIC8vIFJlc29sdmUgdGhlIHBhdGggb3V0c2lkZSBvZiB0aGUgZWZmZWN0IHNvIHRoYXQgd2hlbiBlZmZlY3RzIHJ1biB0d2ljZSBpblxuICAvLyBTdHJpY3RNb2RlIHRoZXkgbmF2aWdhdGUgdG8gdGhlIHNhbWUgcGxhY2VcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8sIFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCksIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIik7XG4gIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHJlbGF0aXZlXG4gIH0pLCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZSwgc3RhdGVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9vdXRsZXRcbiAqL1xuZnVuY3Rpb24gT3V0bGV0KHByb3BzKSB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG4vKipcbiAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZVxuICovXG5mdW5jdGlvbiBSb3V0ZShfcHJvcHMpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIFwiICsgXCJuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgO1xufVxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIGA8Um91dGVyPmAgZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSBgPEJyb3dzZXJSb3V0ZXI+YFxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgYDxTdGF0aWNSb3V0ZXI+YCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxuICovXG5mdW5jdGlvbiBSb3V0ZXIoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgY2hpbGRyZW4gPSBudWxsLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gICAgbmF2aWdhdGlvblR5cGUgPSBBY3Rpb24uUG9wLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZSxcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWY1O1xuICAhIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LlwiICsgXCIgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gUHJlc2VydmUgdHJhaWxpbmcgc2xhc2hlcyBvbiBiYXNlbmFtZSwgc28gd2UgY2FuIGxldCB0aGUgdXNlciBjb250cm9sXG4gIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxuICBsZXQgYmFzZW5hbWUgPSBiYXNlbmFtZVByb3AucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBzdGF0aWNQcm9wLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe1xuICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IGZhbHNlXG4gICAgfSwgZnV0dXJlKVxuICB9KSwgW2Jhc2VuYW1lLCBmdXR1cmUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF0pO1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvblR5cGVcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXksIG5hdmlnYXRpb25UeXBlXSk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLCBcIjxSb3V0ZXIgYmFzZW5hbWU9XFxcIlwiICsgYmFzZW5hbWUgKyBcIlxcXCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgXCIgKyAoXCJcXFwiXCIgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggKyBcIlxcXCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBcIikgKyBcImJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLlwiKSA6IHZvaWQgMDtcbiAgaWYgKGxvY2F0aW9uQ29udGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG5hdmlnYXRpb25Db250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICB2YWx1ZTogbG9jYXRpb25Db250ZXh0XG4gIH0pKTtcbn1cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgYDxSb3V0ZT5gIGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVzXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcyhfcmVmNikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uXG4gIH0gPSBfcmVmNjtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG4vKipcbiAqIENvbXBvbmVudCB0byB1c2UgZm9yIHJlbmRlcmluZyBsYXppbHkgbG9hZGVkIGRhdGEgZnJvbSByZXR1cm5pbmcgZGVmZXIoKVxuICogaW4gYSBsb2FkZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gQXdhaXQoX3JlZjcpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlcnJvckVsZW1lbnQsXG4gICAgcmVzb2x2ZVxuICB9ID0gX3JlZjc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdEVycm9yQm91bmRhcnksIHtcbiAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgIGVycm9yRWxlbWVudDogZXJyb3JFbGVtZW50XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlc29sdmVBd2FpdCwgbnVsbCwgY2hpbGRyZW4pKTtcbn1cbnZhciBBd2FpdFJlbmRlclN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQXdhaXRSZW5kZXJTdGF0dXMpIHtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJwZW5kaW5nXCJdID0gMF0gPSBcInBlbmRpbmdcIjtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJzdWNjZXNzXCJdID0gMV0gPSBcInN1Y2Nlc3NcIjtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJlcnJvclwiXSA9IDJdID0gXCJlcnJvclwiO1xuICByZXR1cm4gQXdhaXRSZW5kZXJTdGF0dXM7XG59KEF3YWl0UmVuZGVyU3RhdHVzIHx8IHt9KTtcbmNvbnN0IG5ldmVyU2V0dGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5jbGFzcyBBd2FpdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiPEF3YWl0PiBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsIGVycm9yLCBlcnJvckluZm8pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBlcnJvckVsZW1lbnQsXG4gICAgICByZXNvbHZlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgIGxldCBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgLy8gRGlkbid0IGdldCBhIHByb21pc2UgLSBwcm92aWRlIGFzIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIC8vIENhdWdodCBhIHJlbmRlciBlcnJvciwgcHJvdmlkZSBpdCBhcyBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHt9KTsgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbiB3YXJuaW5nc1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZW5kZXJFcnJvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlLl90cmFja2VkKSB7XG4gICAgICAvLyBBbHJlYWR5IHRyYWNrZWQgcHJvbWlzZSAtIGNoZWNrIGNvbnRlbnRzXG4gICAgICBwcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHN0YXR1cyA9IFwiX2Vycm9yXCIgaW4gcHJvbWlzZSA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yIDogXCJfZGF0YVwiIGluIHByb21pc2UgPyBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmF3ICh1bnRyYWNrZWQpIHByb21pc2UgLSB0cmFjayBpdFxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlLnRoZW4oZGF0YSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZGF0YVxuICAgICAgfSksIGVycm9yID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZXJyb3JcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgcHJvbWlzZS5fZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvcikge1xuICAgICAgLy8gRnJlZXplIHRoZSBVSSBieSB0aHJvd2luZyBhIG5ldmVyIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmICFlcnJvckVsZW1lbnQpIHtcbiAgICAgIC8vIE5vIGVycm9yRWxlbWVudCwgdGhyb3cgdG8gdGhlIG5lYXJlc3Qgcm91dGUtbGV2ZWwgZXJyb3IgYm91bmRhcnlcbiAgICAgIHRocm93IHByb21pc2UuX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xuICAgICAgLy8gUmVuZGVyIHZpYSBvdXIgZXJyb3JFbGVtZW50XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICBjaGlsZHJlbjogZXJyb3JFbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb21pc2UsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgdG8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbmRpcmVjdGlvbiB0byBsZXZlcmFnZSB1c2VBc3luY1ZhbHVlIGZvciBhIHJlbmRlci1wcm9wIEFQSSBvbiBgPEF3YWl0PmBcbiAqL1xuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KF9yZWY4KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY4O1xuICBsZXQgZGF0YSA9IHVzZUFzeW5jVmFsdWUoKTtcbiAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhKSA6IGNoaWxkcmVuO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHRvUmVuZGVyKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm91dGUgY29uZmlnIGZyb20gYSBSZWFjdCBcImNoaWxkcmVuXCIgb2JqZWN0LCB3aGljaCBpcyB1c3VhbGx5XG4gKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcbiAqIGA8Um91dGVzPmAgdG8gY3JlYXRlIGEgcm91dGUgY29uZmlnIGZyb20gaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvY3JlYXRlLXJvdXRlcy1mcm9tLWNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50UGF0aCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG4gIGxldCByb3V0ZXMgPSBbXTtcbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXG4gICAgICAvLyBjb25kaXRpb25hbHMgaW4gdGhlaXIgcm91dGUgY29uZmlnLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KHJvdXRlcywgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEoZWxlbWVudC50eXBlID09PSBSb3V0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIltcIiArICh0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWUpICsgXCJdIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKCFlbGVtZW50LnByb3BzLmluZGV4IHx8ICFlbGVtZW50LnByb3BzLmNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQW4gaW5kZXggcm91dGUgY2Fubm90IGhhdmUgY2hpbGQgcm91dGVzLlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGxldCByb3V0ZSA9IHtcbiAgICAgIGlkOiBlbGVtZW50LnByb3BzLmlkIHx8IHRyZWVQYXRoLmpvaW4oXCItXCIpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgQ29tcG9uZW50OiBlbGVtZW50LnByb3BzLkNvbXBvbmVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgICAgbG9hZGVyOiBlbGVtZW50LnByb3BzLmxvYWRlcixcbiAgICAgIGFjdGlvbjogZWxlbWVudC5wcm9wcy5hY3Rpb24sXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5LFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQgIT0gbnVsbCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIGhhbmRsZTogZWxlbWVudC5wcm9wcy5oYW5kbGUsXG4gICAgICBsYXp5OiBlbGVtZW50LnByb3BzLmxhenlcbiAgICB9O1xuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCk7XG4gICAgfVxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gIGxldCB1cGRhdGVzID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgQ29tcG9uZW50YCBhbmQgYGVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBIeWRyYXRlRmFsbGJhY2tgIGFuZCBgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmVycm9yRWxlbWVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXg6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEluZGV4XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVuc3RhYmxlX2RhdGFTdHJhdGVneSxcbiAgICB1bnN0YWJsZV9wYXRjaFJvdXRlc09uTWlzczogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51bnN0YWJsZV9wYXRjaFJvdXRlc09uTWlzc1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5cbmV4cG9ydCB7IEF3YWl0LCBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlclByb3ZpZGVyLCBSb3V0ZXMsIERhdGFSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCwgRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIG1hcFJvdXRlUHJvcGVydGllcyBhcyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCB1c2VSb3V0ZUlkIGFzIFVOU0FGRV91c2VSb3V0ZUlkLCB1c2VSb3V0ZXNJbXBsIGFzIFVOU0FGRV91c2VSb3V0ZXNJbXBsLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIGFzIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cywgcmVuZGVyTWF0Y2hlcywgdXNlQWN0aW9uRGF0YSwgdXNlQXN5bmNFcnJvciwgdXNlQXN5bmNWYWx1ZSwgdXNlQmxvY2tlciwgdXNlSHJlZiwgdXNlSW5Sb3V0ZXJDb250ZXh0LCB1c2VMb2FkZXJEYXRhLCB1c2VMb2NhdGlvbiwgdXNlTWF0Y2gsIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlUmV2YWxpZGF0b3IsIHVzZVJvdXRlRXJyb3IsIHVzZVJvdXRlTG9hZGVyRGF0YSwgdXNlUm91dGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlVOU0FGRV9pbnZhcmlhbnQiLCJqb2luUGF0aHMiLCJtYXRjaFBhdGgiLCJVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyIsIlVOU0FGRV93YXJuaW5nIiwicmVzb2x2ZVRvIiwicGFyc2VQYXRoIiwibWF0Y2hSb3V0ZXMiLCJBY3Rpb24iLCJVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJzdHJpcEJhc2VuYW1lIiwiSURMRV9CTE9DS0VSIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiQWJvcnRlZERlZmVycmVkRXJyb3IiLCJjcmVhdGVSb3V0ZXIiLCJOYXZpZ2F0aW9uVHlwZSIsImNyZWF0ZVBhdGgiLCJkZWZlciIsImdlbmVyYXRlUGF0aCIsImpzb24iLCJyZWRpcmVjdCIsInJlZGlyZWN0RG9jdW1lbnQiLCJyZXNvbHZlUGF0aCIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIkRhdGFSb3V0ZXJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwiRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIkF3YWl0Q29udGV4dCIsIk5hdmlnYXRpb25Db250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiUm91dGVDb250ZXh0Iiwib3V0bGV0IiwibWF0Y2hlcyIsImlzRGF0YVJvdXRlIiwiUm91dGVFcnJvckNvbnRleHQiLCJ1c2VIcmVmIiwidG8iLCJfdGVtcCIsIl9yZWY5IiwicmVsYXRpdmUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJfUmVhY3QkdXNlQ29udGV4dCIsInVzZUNvbnRleHQiLCJiYXNlbmFtZSIsIm5hdmlnYXRvciIsIl91c2VSZXNvbHZlZFBhdGgiLCJ1c2VSZXNvbHZlZFBhdGgiLCJoYXNoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJqb2luZWRQYXRobmFtZSIsImNyZWF0ZUhyZWYiLCJ1c2VMb2NhdGlvbiIsImxvY2F0aW9uIiwidXNlTmF2aWdhdGlvblR5cGUiLCJuYXZpZ2F0aW9uVHlwZSIsInVzZU1hdGNoIiwicGF0dGVybiIsIl91c2VMb2NhdGlvbiIsInVzZU1lbW8iLCJuYXZpZ2F0ZUVmZmVjdFdhcm5pbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY2IiLCJpc1N0YXRpYyIsInVzZUxheW91dEVmZmVjdCIsInVzZU5hdmlnYXRlIiwiX1JlYWN0JHVzZUNvbnRleHQyIiwidXNlTmF2aWdhdGVTdGFibGUiLCJ1c2VOYXZpZ2F0ZVVuc3RhYmxlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJfUmVhY3QkdXNlQ29udGV4dDMiLCJmdXR1cmUiLCJfUmVhY3QkdXNlQ29udGV4dDQiLCJfdXNlTG9jYXRpb24yIiwibG9jYXRpb25QYXRobmFtZSIsInJvdXRlUGF0aG5hbWVzSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2N19yZWxhdGl2ZVNwbGF0UGF0aCIsImFjdGl2ZVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJuYXZpZ2F0ZSIsInVzZUNhbGxiYWNrIiwib3B0aW9ucyIsImdvIiwicGF0aCIsInBhcnNlIiwicmVwbGFjZSIsInB1c2giLCJzdGF0ZSIsIk91dGxldENvbnRleHQiLCJ1c2VPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0IiwiY29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwidXNlUGFyYW1zIiwiX1JlYWN0JHVzZUNvbnRleHQ1Iiwicm91dGVNYXRjaCIsInBhcmFtcyIsIl90ZW1wMiIsIl9yZWYxMCIsIl9SZWFjdCR1c2VDb250ZXh0NiIsIl9SZWFjdCR1c2VDb250ZXh0NyIsIl91c2VMb2NhdGlvbjMiLCJ1c2VSb3V0ZXMiLCJyb3V0ZXMiLCJsb2NhdGlvbkFyZyIsInVzZVJvdXRlc0ltcGwiLCJkYXRhUm91dGVyU3RhdGUiLCJfUmVhY3QkdXNlQ29udGV4dDgiLCJfUmVhY3QkdXNlQ29udGV4dDkiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsInJvdXRlIiwicGFyZW50UGF0aCIsIndhcm5pbmdPbmNlIiwiZW5kc1dpdGgiLCJsb2NhdGlvbkZyb21Db250ZXh0IiwiX3BhcnNlZExvY2F0aW9uQXJnJHBhIiwicGFyc2VkTG9jYXRpb25BcmciLCJzdGFydHNXaXRoIiwicmVtYWluaW5nUGF0aG5hbWUiLCJwYXJlbnRTZWdtZW50cyIsInNwbGl0Iiwic2VnbWVudHMiLCJzbGljZSIsImpvaW4iLCJlbGVtZW50IiwidW5kZWZpbmVkIiwiQ29tcG9uZW50IiwibGF6eSIsInJlbmRlcmVkTWF0Y2hlcyIsIl9yZW5kZXJNYXRjaGVzIiwibWFwIiwibWF0Y2giLCJlbmNvZGVMb2NhdGlvbiIsIlBvcCIsIkRlZmF1bHRFcnJvckNvbXBvbmVudCIsImVycm9yIiwidXNlUm91dGVFcnJvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJzdGFjayIsImxpZ2h0Z3JleSIsInByZVN0eWxlcyIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2RlU3R5bGVzIiwiZGV2SW5mbyIsImNvbnNvbGUiLCJGcmFnbWVudCIsInN0eWxlIiwiZm9udFN0eWxlIiwiZGVmYXVsdEVycm9yRWxlbWVudCIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJfUmVhY3QkQ29tcG9uZW50IiwicHJvcHMiLCJfdGhpczIiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2FsbFN1cGVyIiwicmV2YWxpZGF0aW9uIiwiX2luaGVyaXRzIiwiX2NyZWF0ZUNsYXNzIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnJvckluZm8iLCJyZW5kZXIiLCJyb3V0ZUNvbnRleHQiLCJjaGlsZHJlbiIsImNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIlJlbmRlcmVkUm91dGUiLCJfcmVmIiwic3RhdGljQ29udGV4dCIsImVycm9yRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlkIiwiX2RhdGFSb3V0ZXJTdGF0ZTIiLCJfZGF0YVJvdXRlclN0YXRlIiwiZXJyb3JzIiwiZXJyb3JJbmRleCIsImZpbmRJbmRleCIsIm0iLCJrZXlzIiwiTWF0aCIsIm1pbiIsInJlbmRlckZhbGxiYWNrIiwiZmFsbGJhY2tJbmRleCIsInY3X3BhcnRpYWxIeWRyYXRpb24iLCJIeWRyYXRlRmFsbGJhY2siLCJoeWRyYXRlRmFsbGJhY2tFbGVtZW50IiwiX2RhdGFSb3V0ZXJTdGF0ZTMiLCJsb2FkZXJEYXRhIiwibmVlZHNUb1J1bkxvYWRlciIsImxvYWRlciIsInJlZHVjZVJpZ2h0IiwiaW5kZXgiLCJzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2siLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwidXNlUm91dGVDb250ZXh0IiwidXNlQ3VycmVudFJvdXRlSWQiLCJ0aGlzUm91dGUiLCJ1c2VSb3V0ZUlkIiwiVXNlUm91dGVJZCIsInVzZU5hdmlnYXRpb24iLCJVc2VOYXZpZ2F0aW9uIiwibmF2aWdhdGlvbiIsInVzZVJldmFsaWRhdG9yIiwiVXNlUmV2YWxpZGF0b3IiLCJyZXZhbGlkYXRlIiwicm91dGVyIiwidXNlTWF0Y2hlcyIsIl91c2VEYXRhUm91dGVyU3RhdGUiLCJVc2VNYXRjaGVzIiwidXNlTG9hZGVyRGF0YSIsIlVzZUxvYWRlckRhdGEiLCJyb3V0ZUlkIiwidXNlUm91dGVMb2FkZXJEYXRhIiwiVXNlUm91dGVMb2FkZXJEYXRhIiwidXNlQWN0aW9uRGF0YSIsIlVzZUFjdGlvbkRhdGEiLCJhY3Rpb25EYXRhIiwiX3N0YXRlJGVycm9ycyIsIlVzZVJvdXRlRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwiX2RhdGEiLCJ1c2VBc3luY0Vycm9yIiwiX2Vycm9yIiwiYmxvY2tlcklkIiwidXNlQmxvY2tlciIsInNob3VsZEJsb2NrIiwiX3VzZURhdGFSb3V0ZXJDb250ZXh0IiwiVXNlQmxvY2tlciIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlMiIsIl9zbGljZWRUb0FycmF5IiwiYmxvY2tlcktleSIsInNldEJsb2NrZXJLZXkiLCJibG9ja2VyRnVuY3Rpb24iLCJhcmciLCJjdXJyZW50TG9jYXRpb24iLCJuZXh0TG9jYXRpb24iLCJoaXN0b3J5QWN0aW9uIiwidXNlRWZmZWN0IiwiU3RyaW5nIiwiZGVsZXRlQmxvY2tlciIsImdldEJsb2NrZXIiLCJibG9ja2VycyIsImhhcyIsImdldCIsIl91c2VEYXRhUm91dGVyQ29udGV4dDIiLCJVc2VOYXZpZ2F0ZVN0YWJsZSIsImZyb21Sb3V0ZUlkIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIlJvdXRlclByb3ZpZGVyIiwiZmFsbGJhY2tFbGVtZW50IiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJzZXRTdGF0ZUltcGwiLCJfcmVmMTEiLCJ2N19zdGFydFRyYW5zaXRpb24iLCJzZXRTdGF0ZSIsIm5ld1N0YXRlIiwic3Vic2NyaWJlIiwibiIsIm9wdHMiLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJSb3V0ZXIiLCJpbml0aWFsaXplZCIsIkRhdGFSb3V0ZXMiLCJfcmVmMiIsIk1lbW9yeVJvdXRlciIsIl9yZWYzIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJoaXN0b3J5UmVmIiwidjVDb21wYXQiLCJoaXN0b3J5IiwiX1JlYWN0JHVzZVN0YXRlNSIsImFjdGlvbiIsIl9SZWFjdCR1c2VTdGF0ZTYiLCJfcmVmMTIiLCJsaXN0ZW4iLCJOYXZpZ2F0ZSIsIl9yZWY0IiwiX1JlYWN0JHVzZUNvbnRleHQxMCIsIl9SZWFjdCR1c2VDb250ZXh0MTEiLCJfdXNlTG9jYXRpb240IiwianNvblBhdGgiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsIl9yZWY1IiwiX3JlZjUkYmFzZW5hbWUiLCJiYXNlbmFtZVByb3AiLCJfcmVmNSRjaGlsZHJlbiIsImxvY2F0aW9uUHJvcCIsIl9yZWY1JG5hdmlnYXRpb25UeXBlIiwiX3JlZjUkc3RhdGljIiwic3RhdGljUHJvcCIsIm5hdmlnYXRpb25Db250ZXh0IiwiX2xvY2F0aW9uUHJvcCIsIl9sb2NhdGlvblByb3AkcGF0aG5hbSIsIl9sb2NhdGlvblByb3Akc2VhcmNoIiwiX2xvY2F0aW9uUHJvcCRoYXNoIiwiX2xvY2F0aW9uUHJvcCRzdGF0ZSIsIl9sb2NhdGlvblByb3Aka2V5IiwibG9jYXRpb25Db250ZXh0IiwidHJhaWxpbmdQYXRobmFtZSIsIlJvdXRlcyIsIl9yZWY2IiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiQXdhaXQiLCJfcmVmNyIsInJlc29sdmUiLCJBd2FpdEVycm9yQm91bmRhcnkiLCJSZXNvbHZlQXdhaXQiLCJBd2FpdFJlbmRlclN0YXR1cyIsIm5ldmVyU2V0dGxlZFByb21pc2UiLCJQcm9taXNlIiwiX1JlYWN0JENvbXBvbmVudDIiLCJfdGhpczMiLCJfdGhpcyRwcm9wcyIsInByb21pc2UiLCJwZW5kaW5nIiwic3VjY2VzcyIsImRlZmluZVByb3BlcnR5IiwicmVuZGVyRXJyb3IiLCJyZWplY3QiLCJfdHJhY2tlZCIsInRoZW4iLCJkYXRhIiwiX3JlZjgiLCJ0b1JlbmRlciIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImlzVmFsaWRFbGVtZW50IiwidHJlZVBhdGgiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJ0eXBlIiwibmFtZSIsImNhc2VTZW5zaXRpdmUiLCJoYXNFcnJvckJvdW5kYXJ5Iiwic2hvdWxkUmV2YWxpZGF0ZSIsImhhbmRsZSIsInJlbmRlck1hdGNoZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJ1cGRhdGVzIiwiY3JlYXRlTWVtb3J5Um91dGVyIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaHlkcmF0aW9uRGF0YSIsInVuc3RhYmxlX2RhdGFTdHJhdGVneSIsInVuc3RhYmxlX3BhdGNoUm91dGVzT25NaXNzIiwiaW5pdGlhbGl6ZSIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiVU5TQUZFX0xvY2F0aW9uQ29udGV4dCIsIlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX3VzZVJvdXRlSWQiLCJVTlNBRkVfdXNlUm91dGVzSW1wbCIsImNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/index.js\n");

/***/ })

};
;